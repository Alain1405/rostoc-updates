name: Build Rostoc Core

on:
  workflow_call:
    inputs:
      ref:
        description: "Branch, tag, or SHA to build from private repo"
        required: false
        type: string
        default: "main"
      commit_sha:
        description: "Commit SHA of the private repo (for stamping)"
        required: false
        type: string
      initiator:
        description: "Who triggered the run (for logging/summaries)"
        required: false
        type: string
      is_release:
        description: "Whether to execute release publishing steps"
        required: true
        type: boolean
  workflow_dispatch:
    inputs:
      ref:
        description: "Branch, tag, or SHA to build from private repo"
        required: false
        default: "main"
      commit_sha:
        description: "Commit SHA of the private repo (for stamping)"
        required: false
      initiator:
        description: "Who triggered the run (for logging/summaries)"
        required: false
      is_release:
        description: "Whether to execute release publishing steps"
        required: true
        type: boolean
        default: false

permissions:
  contents: write # Push updates to this repo / checkout private repo
  pages: write # Deploy Pages when releasing
  id-token: write # OIDC for Pages when releasing

env:
  PRIVATE_REPO: alain1405/rostoc
  UPDATES_DIR: updates
  VERSION_FILE: version.txt
  PYTAURI_GEN_TS: 0
  LC_ALL: en_US.UTF-8
  LANG: en_US.UTF-8
  LC_CTYPE: en_US.UTF-8

jobs:
  set-status:
    runs-on: ubuntu-latest
    env:
      TARGET_SHA: ${{ inputs.commit_sha || github.sha }}
      STATUS_CONTEXT: ${{ inputs.is_release && 'rostoc-updates/release' || 'rostoc-updates/ci' }}
      STATUS_DESCRIPTION: ${{ inputs.is_release && 'Public release build running' || 'Public CI build running' }}
    steps:
      - name: Detect status token
        id: detect-status-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Status updates skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; omitting private repo commit status.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Set pending status in private repo
        if: ${{ env.TARGET_SHA != '' && steps.detect-status-token.outputs.available == 'true' }}
        uses: actions/github-script@v7
        env:
          TARGET_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          github-token: ${{ secrets.UPDATES_REPO_TOKEN }}
          result-encoding: string
          script: |
            const [owner, repo] = process.env.PRIVATE_REPO.split('/');
            const sha = process.env.TARGET_SHA;
            const context = process.env.STATUS_CONTEXT;
            const description = process.env.STATUS_DESCRIPTION;
            const targetUrl = process.env.TARGET_URL;

            if (!owner || !repo) {
              core.warning(`Unable to parse PRIVATE_REPO env "${process.env.PRIVATE_REPO}"; skipping status update.`);
              return 'skipped';
            }

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state: 'pending',
              context,
              description,
              target_url: targetUrl
            });

            core.info(`Set pending status (${context}) on ${owner}/${repo}@${sha}`);
            return 'pending-set';

  build-macos:
    needs: set-status
    runs-on: macos-14
    timeout-minutes: 50
    outputs:
      version: ${{ steps.extract_version.outputs.version }}
      tarball: ${{ steps.prepare_artifacts.outputs.tarball }}
      signature: ${{ steps.prepare_artifacts.outputs.signature }}
    steps:
      # --- Checkout this updates repo ---
      - name: Checkout updates repo
        if: inputs.is_release
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: updates-repo

      # --- SSH method to read the private repo ---
      - name: Setup SSH agent for private repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}

      - name: Add GitHub to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout private repo (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src
          fetch-depth: 0
          sparse-checkout: |
            /*
            !/references/
          sparse-checkout-cone-mode: false

      # --- Setup toolchains ---
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable Corepack (pnpm)
        run: corepack enable

      - name: Derive pnpm store path
        id: pnpm-store
        shell: bash
        run: |
          set -euo pipefail
          cd private-src
          echo "[INFO] pnpm version: $(pnpm --version || true)" >&2
          STORE_PATH=$(pnpm store path 2>/dev/null | tr -d '\r' || true)
          if [ -z "${STORE_PATH}" ]; then
            echo "[WARN] pnpm store path empty; falling back to default ~/.pnpm-store" >&2
            STORE_PATH="$HOME/.pnpm-store"
          fi
          mkdir -p "$STORE_PATH" || true
          echo "Using STORE_PATH=$STORE_PATH" >&2
          echo "STORE_PATH=$STORE_PATH" >> "$GITHUB_OUTPUT"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ hashFiles('private-src/pnpm-lock.yaml') }}
          restore-keys: pnpm-${{ runner.os }}-

      - name: Install uv (Python package manager)
        working-directory: private-src
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "UV_BIN=$HOME/.local/bin" >> $GITHUB_ENV
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache Python wheels
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/Library/Caches/pip
            ~/.cache/uv
            ~/Library/Caches/uv
          key: python-wheel-${{ runner.os }}-${{ hashFiles('private-src/uv.lock') }}
          restore-keys: |
            python-wheel-${{ runner.os }}-

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install sccache
        run: |
          curl -L https://github.com/mozilla/sccache/releases/download/v0.7.7/sccache-v0.7.7-aarch64-apple-darwin.tar.gz -o sccache.tgz
          tar -xzf sccache.tgz --strip-components=1
          sudo mv sccache /usr/local/bin/sccache
          export SCCACHE_DIR="$RUNNER_TEMP/sccache"
          mkdir -p "$SCCACHE_DIR"
          echo "SCCACHE_DIR=$SCCACHE_DIR" >> $GITHUB_ENV

      - name: Cache Rust (registry + git + sccache)
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cache/sccache
          key: rust-${{ runner.os }}-${{ hashFiles('private-src/**/Cargo.lock') }}
          restore-keys: rust-${{ runner.os }}-

      # --- Build Rostoc ---
      - name: Download embedded Python
        working-directory: private-src
        run: bash scripts/macos/download-py.sh

      - name: Assemble staged runtime
        working-directory: private-src
        env:
          ENABLE_RUNTIME_CACHE: "1"
        run: bash scripts/assemble_runtime.sh

      - name: Install JS dependencies
        working-directory: private-src
        run: pnpm install --frozen-lockfile

      - name: Stamp build version
        working-directory: private-src
        env:
          GITHUB_SHA: ${{ inputs.commit_sha || github.sha }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: scripts/ci/stamp_dev_version.sh

      - name: Extract version
        id: extract_version
        working-directory: private-src
        run: |
          set -euo pipefail
          VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "[INFO] Building version: $VERSION"

      - name: Build application (with signing)
        working-directory: private-src
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          RUSTC_WRAPPER: sccache
          SCCACHE_DIR: ${{ env.SCCACHE_DIR }}
          SCCACHE_CACHE_SIZE: 2G
          ALLOW_PARTIAL_BUNDLE: 1
        run: |
          set -euo pipefail
          # Prevent code leaks in logs - disable command echoing for sensitive parts
          set +x
          bash scripts/macos/build.sh
          set -x
          sccache --show-stats || true

      - name: Verify app bundle
        working-directory: private-src
        run: bash scripts/verify_app_bundle.sh

      - name: Locate macOS app bundle
        id: locate_macos_bundle
        working-directory: private-src
        run: |
          set -euo pipefail
          SEARCH_DIRS=(target/bundle-release/bundle/macos src-tauri/target/bundle-release/bundle/macos src-tauri/target/release/bundle/macos target/release/bundle/macos)
          APP_PATH=""
          for dir in "${SEARCH_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              cand=$(find "$dir" -maxdepth 1 -type d -name '*.app' -print -quit 2>/dev/null || true)
              if [ -n "$cand" ]; then
                APP_PATH="$cand"
                break
              fi
            fi
          done
          if [ -z "$APP_PATH" ]; then
            echo "::error::No .app bundle located in expected directories"
            for dir in "${SEARCH_DIRS[@]}"; do
              if [ -d "$dir" ]; then
                echo "[INFO] Contents of $dir:"
                ls -al "$dir"
              else
                echo "[INFO] Missing search dir: $dir"
              fi
            done
            exit 1
          fi
          PY_CANDIDATES=("$APP_PATH/Contents/Resources/pyembed/python/bin/python3" "$APP_PATH/Contents/Resources/bin/python3")
          PYBIN=""
          for py in "${PY_CANDIDATES[@]}"; do
            if [ -x "$py" ]; then
              PYBIN="$py"
              break
            fi
          done
          APP_PARENT=$(dirname "$APP_PATH")
          APP_NAME=$(basename "$APP_PATH")
          echo "app_path=$APP_PATH" >> "$GITHUB_OUTPUT"
          echo "bundle_dir=$APP_PARENT" >> "$GITHUB_OUTPUT"
          echo "app_name=$APP_NAME" >> "$GITHUB_OUTPUT"
          echo "python_path=$PYBIN" >> "$GITHUB_OUTPUT"
          if [ -z "$PYBIN" ]; then
            echo "::warning::Embedded python binary not found inside bundle (expected pyembed/python/bin/python3 or Resources/bin/python3)"
          fi

      - name: Runtime smoke test (mac)
        if: steps.locate_macos_bundle.outputs.app_path != ''
        working-directory: private-src
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
          PYBIN_HINT: ${{ steps.locate_macos_bundle.outputs.python_path }}
        run: |
          set -euo pipefail
          if [ -z "${APP_BUNDLE}" ]; then
            echo '::error::app_path output missing from locate step'
            exit 1
          fi
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "::error::Resolved app bundle directory not found: $ABS_APP"
            ls -al "$GITHUB_WORKSPACE/private-src"
            exit 1
          fi
          PYBIN="${PYBIN_HINT}"
          if [[ -n "$PYBIN" && "$PYBIN" != /* ]]; then
            PYBIN="$GITHUB_WORKSPACE/private-src/$PYBIN"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            echo "[INFO] Falling back to bundle-local search for python3"
            CANDIDATES=(
              "$ABS_APP/Contents/Resources/pyembed/python/bin/python3"
              "$ABS_APP/Contents/Resources/bin/python3"
            )
            for cand in "${CANDIDATES[@]}"; do
              if [ -x "$cand" ]; then
                PYBIN="$cand"
                break
              fi
            done
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            echo '::error::Embedded python3 not found in bundle'
            find "$ABS_APP/Contents/Resources" -maxdepth 5 -name 'python3' -print || true
            exit 1
          fi
          echo "[INFO] Running embedded python smoke test: $PYBIN"
          "$PYBIN" -c "import sys, json, coro_profiles; print(json.dumps({'result':'OK','py':sys.version.split()[0]}))"

      - name: Archive macOS preview artifacts
        if: steps.locate_macos_bundle.outputs.app_path != ''
        id: archive_macos_preview
        working-directory: private-src
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
          BUNDLE_DIR: ${{ steps.locate_macos_bundle.outputs.bundle_dir }}
          APP_NAME: ${{ steps.locate_macos_bundle.outputs.app_name }}
        run: |
          set -euo pipefail
          if [ -z "${APP_BUNDLE}" ] || [ -z "${BUNDLE_DIR}" ] || [ -z "${APP_NAME}" ]; then
            echo "::error::Missing bundle metadata from locate_macos_bundle step"
            exit 1
          fi
          if [[ "${BUNDLE_DIR}" == /* ]]; then
            ABS_BUNDLE_DIR="${BUNDLE_DIR}"
          else
            ABS_BUNDLE_DIR="$GITHUB_WORKSPACE/private-src/${BUNDLE_DIR}"
          fi
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_BUNDLE_DIR" ]; then
            echo "::error::Bundle directory not found: $ABS_BUNDLE_DIR"
            exit 1
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "::error::App bundle not found: $ABS_APP"
            ls -al "$ABS_BUNDLE_DIR"
            exit 1
          fi
          if [ "${APP_NAME}" != "$(basename "$ABS_APP")" ]; then
            echo "::warning::App name output (${APP_NAME}) did not match bundle basename ($(basename "$ABS_APP"))"
          fi
          codesign --force --deep -s - "$ABS_APP" || echo "Ad-hoc codesign failed (continuing)"
          tar -czf coro-macos-build-preview.tar.gz -C "$ABS_BUNDLE_DIR" "$APP_NAME"
          ditto -c -k --sequesterRsrc --keepParent "$ABS_APP" coro-macos-build-preview.zip || echo "ditto zip failed"

      - name: Upload macOS preview artifacts
        if: steps.archive_macos_preview.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: macos-preview
          path: |
            private-src/coro-macos-build-preview.tar.gz
            private-src/coro-macos-build-preview.zip
          if-no-files-found: ignore

      - name: Detect release upload token
        if: inputs.is_release
        id: detect-release-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Release asset upload skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; skipping release artifact upload.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Locate updater artifacts
        id: locate
        working-directory: private-src
        run: |
          set -euo pipefail
          # Prefer bundle-release profile artifacts
          TARBALL=$(find target/bundle-release/bundle/macos -name 'Rostoc.app.tar.gz' -print -quit 2>/dev/null || true)
          if [[ -z "$TARBALL" ]]; then
            TARBALL=$(find target/bundle-release/bundle/macos -name 'Coro.app.tar.gz' -print -quit 2>/dev/null || true)
          fi
          if [[ -z "$TARBALL" ]]; then
            TARBALL=$(find target/bundle-release/bundle/macos -name '*.app.tar.gz' -print -quit 2>/dev/null || true)
          fi

          SIG_FILE=""
          if [[ -n "$TARBALL" ]]; then
            SIG_FILE="${TARBALL}.sig"
          fi

          echo "Tarball: $TARBALL" >&2
          echo "Signature: $SIG_FILE" >&2

          if [[ -z "$TARBALL" ]]; then echo 'Missing updater tarball (.app.tar.gz)'; exit 1; fi
          if [[ -z "$SIG_FILE" || ! -f "$SIG_FILE" ]]; then
            echo 'Missing updater signature (.app.tar.gz.sig)'; exit 1
          fi

          echo "tarball=$TARBALL" >> $GITHUB_OUTPUT
          echo "signature=$SIG_FILE" >> $GITHUB_OUTPUT

      - name: Prepare update bundle
        id: prepare_artifacts
        working-directory: private-src
        run: |
          set -euo pipefail
          TARBALL="${{ steps.locate.outputs.tarball }}"
          SIGNATURE="${{ steps.locate.outputs.signature }}"
          VERSION="${{ steps.extract_version.outputs.version }}"

          # Create updates directory
          mkdir -p "../${{ env.UPDATES_DIR }}/macos"

          # Copy artifacts with version-tagged names
          TARBALL_NAME="Rostoc-${VERSION}-darwin-aarch64.app.tar.gz"
          cp "$TARBALL" "../${{ env.UPDATES_DIR }}/macos/$TARBALL_NAME"
          cp "$SIGNATURE" "../${{ env.UPDATES_DIR }}/macos/${TARBALL_NAME}.sig"

          # Also copy as latest for convenience
          cp "$TARBALL" "../${{ env.UPDATES_DIR }}/macos/Rostoc.app.tar.gz"
          cp "$SIGNATURE" "../${{ env.UPDATES_DIR }}/macos/Rostoc.app.tar.gz.sig"

          # Stamp version file
          date -u +"%Y-%m-%dT%H:%M:%SZ" > "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"
          echo "version=${VERSION}" >> "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"
          echo "git_sha=$(git rev-parse --short HEAD)" >> "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"

          # Generate checksums
          (cd "../${{ env.UPDATES_DIR }}/macos" && shasum -a 256 *.tar.gz > checksums.txt)

          echo "tarball_name=$TARBALL_NAME" >> $GITHUB_OUTPUT

      - name: Upload release assets to private repo
        if: inputs.is_release && steps.detect-release-token.outputs.available == 'true'
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.UPDATES_REPO_TOKEN }}
          owner: alain1405
          repo: rostoc
          tag: ${{ inputs.ref }}
          draft: true
          allowUpdates: true
          artifacts: |
            updates/macos/Rostoc.app.tar.gz
            updates/macos/Rostoc.app.tar.gz.sig
            updates/version.txt
          artifactContentType: application/octet-stream

      - name: Generate latest.json
        if: inputs.is_release
        working-directory: updates-repo
        env:
          VERSION: ${{ steps.extract_version.outputs.version }}
          TARBALL_NAME: ${{ steps.prepare_artifacts.outputs.tarball_name }}
        run: |
          set -euo pipefail

          # Read signature
          SIG=$(cat "../${{ env.UPDATES_DIR }}/macos/${TARBALL_NAME}.sig")
          DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          NOTES="Release ${VERSION}"
          URL="https://alain1405.github.io/rostoc-updates/macos/${TARBALL_NAME}"

          # Generate latest.json
          jq -n \
            --arg v "$VERSION" \
            --arg sig "$SIG" \
            --arg date "$DATE" \
            --arg notes "$NOTES" \
            --arg url "$URL" \
            '{
              version: $v,
              notes: $notes,
              pub_date: $date,
              platforms: {
                "darwin-aarch64": {
                  url: $url,
                  signature: $sig
                }
              }
            }' > "../${{ env.UPDATES_DIR }}/latest.json"

          echo 'Generated latest.json:'
          cat "../${{ env.UPDATES_DIR }}/latest.json"

      - name: Upload artifacts for Pages deployment
        if: inputs.is_release
        uses: actions/upload-artifact@v4
        with:
          name: rostoc-updates
          path: ${{ env.UPDATES_DIR }}/*

  build-windows:
    needs: set-status
    runs-on: windows-2022
    timeout-minutes: 45
    outputs:
      version: ${{ steps.extract_version_win.outputs.version }}
      installer_name: ${{ steps.prepare_windows_updates.outputs.versioned_name }}
      installer_latest: ${{ steps.prepare_windows_updates.outputs.latest_name }}
      installer_checksum: ${{ steps.prepare_windows_updates.outputs.checksum }}
    steps:
      - name: Setup SSH agent for private repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}

      - name: Add GitHub to known_hosts
        shell: bash
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout private repo (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable Corepack (pnpm)
        run: corepack enable

      - name: Derive pnpm store path
        id: windows-pnpm-store
        shell: bash
        run: |
          set -euo pipefail
          cd private-src
          echo "[INFO] pnpm version: $(pnpm --version || true)" >&2
          STORE_PATH=$(pnpm store path 2>/dev/null | tr -d '\r' || true)
          if [ -z "${STORE_PATH}" ]; then
            echo "[WARN] pnpm store path empty; falling back to default ~/.pnpm-store" >&2
            STORE_PATH="$HOME/.pnpm-store"
          fi
          mkdir -p "$STORE_PATH" || true
          echo "Using STORE_PATH=$STORE_PATH" >&2
          echo "STORE_PATH=$STORE_PATH" >> "$GITHUB_OUTPUT"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.windows-pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ hashFiles('private-src/pnpm-lock.yaml') }}
          restore-keys: pnpm-${{ runner.os }}-

      - name: Cache Python wheels
        uses: actions/cache@v4
        with:
          path: |
            ~\AppData\Local\pip\Cache
            ~\.cache\pip
            ~\AppData\Local\uv
          key: python-wheel-${{ runner.os }}-${{ hashFiles('private-src/uv.lock') }}
          restore-keys: |
            python-wheel-${{ runner.os }}-

      - name: Cache embedded Python
        uses: actions/cache@v4
        with:
          path: private-src/src-tauri/pyembed
          key: pyembed-${{ runner.os }}-${{ hashFiles('private-src/scripts/windows/download-py.ps1') }}
          restore-keys: |
            pyembed-${{ runner.os }}-

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install uv (Python helper)
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $script = Invoke-RestMethod -Uri 'https://astral.sh/uv/install.ps1'
          Invoke-Expression $script
          "$env:USERPROFILE\.local\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          Add-Content -Path $env:GITHUB_ENV -Value "UV_BIN=$($env:USERPROFILE)\.local\bin"

      - name: Install sccache
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $version = 'v0.7.7'
          $zipPath = Join-Path $env:RUNNER_TEMP 'sccache.zip'
          $extractDir = Join-Path $env:RUNNER_TEMP 'sccache'
          Invoke-WebRequest -Uri "https://github.com/mozilla/sccache/releases/download/$version/sccache-$version-x86_64-pc-windows-msvc.zip" -OutFile $zipPath
          if (Test-Path $extractDir) { Remove-Item $extractDir -Recurse -Force }
          Expand-Archive -Path $zipPath -DestinationPath $extractDir
          $exe = Get-ChildItem -Path $extractDir -Recurse -Filter sccache.exe | Select-Object -First 1
          if (-not $exe) { Write-Error 'sccache.exe not found in archive'; exit 1 }
          $binDir = Join-Path $env:USERPROFILE 'bin'
          if (-not (Test-Path $binDir)) { New-Item -ItemType Directory -Path $binDir | Out-Null }
          Copy-Item $exe.FullName (Join-Path $binDir 'sccache.exe') -Force
          "$binDir" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          Add-Content -Path $env:GITHUB_ENV -Value "SCCACHE_DIR=$($env:LOCALAPPDATA)\Mozilla\sccache"

      - name: Cache Rust toolchain and sccache
        uses: actions/cache@v4
        with:
          path: |
            ~\.cargo\registry
            ~\.cargo\git
            ~\AppData\Local\Mozilla\sccache
          key: rust-${{ runner.os }}-${{ hashFiles('private-src/**/Cargo.lock') }}
          restore-keys: |
            rust-${{ runner.os }}-

      - name: Configure Cargo environment
        shell: bash
        run: |
          {
            echo CARGO_INCREMENTAL=0
            echo CARGO_TERM_COLOR=always
          } >> "$GITHUB_ENV"

      - name: Download embedded Python
        working-directory: private-src
        shell: pwsh
        run: scripts/windows/download-py.ps1

      - name: Assemble staged runtime
        working-directory: private-src
        shell: bash
        env:
          ENABLE_RUNTIME_CACHE: "1"
        run: |
          set -euo pipefail
          python scripts/assemble_runtime.py
          head -n 80 build/runtime_staging/runtime_manifest.json || true

      - name: Install JS dependencies
        working-directory: private-src
        run: pnpm install --frozen-lockfile

      - name: Stamp build version
        working-directory: private-src
        shell: bash
        env:
          GITHUB_SHA: ${{ inputs.commit_sha || github.sha }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: scripts/ci/stamp_dev_version.sh

      - name: Extract version
        id: extract_version_win
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $content = Get-Content src-tauri/tauri.conf.json -Raw | ConvertFrom-Json
          if (-not $content.version) {
            throw 'Version not found in src-tauri/tauri.conf.json'
          }
          "version=$($content.version)" >> $env:GITHUB_OUTPUT

      - name: Build application
        working-directory: private-src
        shell: bash
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          ALLOW_PARTIAL_BUNDLE: 1
          RUSTC_WRAPPER: sccache
          SCCACHE_DIR: ${{ env.SCCACHE_DIR }}
          SCCACHE_CACHE_SIZE: 2G
        run: |
          set -euo pipefail
          EMBED_PY="build/runtime_staging/pyembed/python/python.exe"
          if [ ! -f "$EMBED_PY" ]; then
            echo "[ERR] Embedded python exe missing at $EMBED_PY" >&2
            exit 2
          fi
          export PYO3_PYTHON="$(pwd)/$EMBED_PY"
          echo "[INFO] Using PYO3_PYTHON=$PYO3_PYTHON" >&2
          find target -maxdepth 7 -name pyo3-build-config.txt -print -delete 2>/dev/null || true
          rm -rf target/release/build/pyo3* target/debug/build/pyo3* 2>/dev/null || true
          pnpm tauri build
          sccache --show-stats || true

      - name: Check Python DLL linkage
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          EXE=$(find target -type f -iname 'rostoc.exe' | head -n1 || true)
          if [ -z "$EXE" ]; then
            echo 'Rostoc.exe not found; available executables:' >&2
            find target -maxdepth 4 -type f -print || true
            exit 1
          fi
          echo "[INFO] Scanning for python DLL references in $EXE" >&2
          strings "$EXE" | grep -iE 'python3[0-9]+\.dll' | sort -u || echo '[WARN] No python3*.dll tokens found'
          if command -v objdump >/dev/null 2>&1; then
            objdump -p "$EXE" | grep -i 'DLL Name' | head -n 40 || true
          fi

      - name: Embed and verify runtime
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          python3 scripts/embed_windows_runtime.py --verify

      - name: Runtime smoke test
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          PYBIN=$(find target -type f -path '*resources/pyembed/python/python.exe' -print -quit || true)
          if [ -z "$PYBIN" ]; then
            echo 'Embedded python.exe not found'
            exit 1
          fi
          echo "[INFO] Running embedded python smoke test: $PYBIN" >&2
          RAW_JSON="$($PYBIN scripts/ci/windows_runtime_smoke.py)"
          echo "[SMOKE]$RAW_JSON"
          export RAW_JSON
          python3 scripts/ci/validate_windows_smoke.py || echo "[WARN] Smoke validation non-strict failure (continuing)" >&2

      - name: Launch executable smoke (non-fatal)
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Continue'
          Write-Host '[INFO] Starting exe launch smoke (non-fatal)'
          scripts/ci/windows_run_exe_smoke.ps1 -TimeoutSeconds 6

      - name: Upload exe launch diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-exe-launch
          path: |
            private-src/scripts/ci/windows_exe_launch.json
          if-no-files-found: ignore

      - name: Upload smoke diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-smoke-debug
          path: |
            private-src/windows_runtime_smoke_debug.json
          if-no-files-found: ignore

      - name: Archive Windows artifacts
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $exe = Get-ChildItem -Path target -Recurse -Filter Rostoc.exe | Select-Object -First 1
          if (-not $exe) { Write-Error 'No Rostoc.exe found for archiving'; exit 1 }
          $bindir = Split-Path -Parent $exe.FullName
          Write-Host "[INFO] Found exe at $($exe.FullName) (bindir=$bindir)"
          $stage = "windows_bundle_stage"
          if (Test-Path $stage) { Remove-Item $stage -Recurse -Force }
          New-Item -ItemType Directory -Path $stage | Out-Null
          Copy-Item $exe.FullName (Join-Path $stage $exe.Name)
          if (Test-Path (Join-Path $bindir 'resources')) {
            Copy-Item (Join-Path $bindir 'resources') (Join-Path $stage 'resources') -Recurse
          }
          $dllPatterns = @('python3*.dll','vcruntime140.dll','vcruntime140_1.dll')
          foreach ($pat in $dllPatterns) {
            $matches = Get-ChildItem -Path $bindir -Filter $pat -ErrorAction SilentlyContinue
            foreach ($m in $matches) {
              Copy-Item $m.FullName (Join-Path $stage $m.Name) -Force
              Write-Host "[INFO] Included DLL $($m.Name)"
            }
          }
          if (Test-Path build/runtime_staging/runtime_manifest.json) {
            Copy-Item build/runtime_staging/runtime_manifest.json windows_runtime_manifest.json -ErrorAction SilentlyContinue
          }
          $zipPath = 'coro-windows-bundle.zip'
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path (Join-Path $stage '*') -DestinationPath $zipPath -Force
          Write-Host "[INFO] Created $zipPath"

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-preview
          path: |
            private-src/coro-windows-bundle.zip
            private-src/windows_runtime_manifest.json
          if-no-files-found: error

      - name: Locate Windows updater artifacts
        if: inputs.is_release
        id: locate_windows_updater
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $patterns = @('*.msi', '*.msi.zip', '*setup*.exe', '*.exe', '*.zip')
          $selected = $null
          foreach ($pattern in $patterns) {
            $found = Get-ChildItem -Path target -Recurse -File -Filter $pattern -ErrorAction SilentlyContinue | Where-Object {
              $_.FullName -match 'bundle'
            } | Sort-Object LastWriteTime -Descending | Select-Object -First 1
            if ($found) {
              $selected = $found
              break
            }
          }
          if (-not $selected) {
            throw 'No Windows installer artifact found under target/'
          }
          $sigPath = "$($selected.FullName).sig"
          if (-not (Test-Path $sigPath)) {
            $sigCandidate = Get-ChildItem -Path $selected.DirectoryName -Filter "$($selected.BaseName)*.sig" -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($sigCandidate) {
              $sigPath = $sigCandidate.FullName
            } else {
              throw "Signature file not found for $($selected.Name)"
            }
          }
          "artifact=$($selected.FullName)" >> $env:GITHUB_OUTPUT
          "artifact_name=$($selected.Name)" >> $env:GITHUB_OUTPUT
          "signature=$sigPath" >> $env:GITHUB_OUTPUT

      - name: Prepare Windows update bundle
        if: inputs.is_release
        id: prepare_windows_updates
        working-directory: private-src
        shell: pwsh
        env:
          UPDATES_DIR: ${{ env.UPDATES_DIR }}
        run: |
          $ErrorActionPreference = 'Stop'
          $version = '${{ steps.extract_version_win.outputs.version }}'
          if ([string]::IsNullOrWhiteSpace($version)) {
            throw 'Version output missing from extract_version_win step'
          }
          $artifactPath = '${{ steps.locate_windows_updater.outputs.artifact }}'
          $signaturePath = '${{ steps.locate_windows_updater.outputs.signature }}'
          if ([string]::IsNullOrWhiteSpace($artifactPath) -or -not (Test-Path -LiteralPath $artifactPath)) {
            throw "Installer artifact '$artifactPath' missing"
          }
          if ([string]::IsNullOrWhiteSpace($signaturePath) -or -not (Test-Path -LiteralPath $signaturePath)) {
            throw "Signature file '$signaturePath' missing"
          }
          $artifact = Get-Item -LiteralPath $artifactPath
          $signature = Get-Item -LiteralPath $signaturePath
          $platform = 'windows-x86_64'
          $parent = Split-Path -Parent $PWD
          $updatesRoot = Join-Path $parent $env:UPDATES_DIR
          if (-not (Test-Path -LiteralPath $updatesRoot)) {
            New-Item -ItemType Directory -Path $updatesRoot | Out-Null
          }
          $windowsDir = Join-Path $updatesRoot 'windows'
          if (-not (Test-Path -LiteralPath $windowsDir)) {
            New-Item -ItemType Directory -Path $windowsDir | Out-Null
          }
          $extension = $artifact.Extension
          if ($artifact.Name -like '*.msi.zip' -or $artifact.Name -like '*.exe.zip') {
            $extension = '.zip'
          }
          if (-not $extension) {
            $extension = [System.IO.Path]::GetExtension($artifact.Name)
          }
          $versionedName = "Rostoc-$version-$platform$extension"
          $versionedPath = Join-Path $windowsDir $versionedName
          Copy-Item -LiteralPath $artifact.FullName -Destination $versionedPath -Force
          $sigTarget = "$versionedPath.sig"
          Copy-Item -LiteralPath $signature.FullName -Destination $sigTarget -Force
          $latestName = "Rostoc-$platform$extension"
          $latestPath = Join-Path $windowsDir $latestName
          Copy-Item -LiteralPath $artifact.FullName -Destination $latestPath -Force
          Copy-Item -LiteralPath $signature.FullName -Destination "$latestPath.sig" -Force
          $hash = Get-FileHash -Path $versionedPath -Algorithm SHA256
          $checksumPath = Join-Path $windowsDir 'checksums.txt'
          "$($hash.Hash)  $versionedName" | Out-File -FilePath $checksumPath -Encoding utf8
          "versioned_name=$versionedName" >> $env:GITHUB_OUTPUT
          "latest_name=$latestName" >> $env:GITHUB_OUTPUT
          "checksum=$($hash.Hash)" >> $env:GITHUB_OUTPUT

      - name: Upload artifacts for Pages deployment (Windows)
        if: inputs.is_release
        uses: actions/upload-artifact@v4
        with:
          name: rostoc-updates-windows
          path: updates/windows/*

  publish-to-pages:
    needs:
      - build-macos
      - build-windows
    if: inputs.is_release
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Checkout updates repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: rostoc-updates
          path: updates

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: rostoc-updates-windows
          path: updates

      - name: Merge Windows entry into latest.json
        run: |
          set -euo pipefail
          VERSION='${{ needs.build-macos.outputs.version }}'
          if [[ ! -f updates/latest.json ]]; then
            echo "::error::updates/latest.json not found prior to merge" >&2
            exit 1
          fi
          shopt -s nullglob
          files=(updates/windows/Rostoc-${VERSION}-windows-x86_64.*)
          win_file=""
          for f in "${files[@]}"; do
            if [[ "$f" != *.sig ]]; then
              win_file="$f"
              break
            fi
          done
          if [[ -z "$win_file" ]]; then
            echo "::error::No Windows installer artifact found for version $VERSION under updates/windows" >&2
            ls -al updates/windows || true
            exit 1
          fi
          sig_file="${win_file}.sig"
          if [[ ! -f "$sig_file" ]]; then
            echo "::error::Missing signature for Windows artifact: $sig_file" >&2
            exit 1
          fi
          signature=$(cat "$sig_file")
          url="https://alain1405.github.io/rostoc-updates/windows/$(basename "$win_file")"
          tmp=updates/latest.json.tmp
          jq --arg url "$url" --arg sig "$signature" '.platforms["windows-x86_64"] = { url: $url, signature: $sig }' updates/latest.json > "$tmp"
          mv "$tmp" updates/latest.json

      # - name: Commit & push updates (optional - for history)
      #   run: |
      #     git config user.name "github-actions[bot]"
      #     git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      #     git add updates || true
      #     if ! git diff --cached --quiet; then
      #       git commit -m "chore: publish updates v${{ needs.build-macos.outputs.version }} ($(date -u +%F))"
      #       git push
      #     else
      #       echo "No changes to commit"
      #     fi

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: updates

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Summary
        run: |
          echo "## 🚀 Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.build-macos.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Updates URL:** https://alain1405.github.io/rostoc-updates/latest.json" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts:**" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ needs.build-macos.outputs.tarball }}" ]; then
            echo "- macOS artifact: macos/${{ needs.build-macos.outputs.tarball }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- macOS artifact: macos/Rostoc.app.tar.gz" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "${{ needs.build-windows.outputs.installer_name }}" ]; then
            echo "- Windows artifact: windows/${{ needs.build-windows.outputs.installer_name }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "**Pages URL:** ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY

  finalize-status:
    runs-on: ubuntu-latest
    needs:
      - build-macos
      - build-windows
    if: ${{ always() }}
    env:
      TARGET_SHA: ${{ inputs.commit_sha || github.sha }}
      STATUS_CONTEXT: ${{ inputs.is_release && 'rostoc-updates/release' || 'rostoc-updates/ci' }}
    steps:
      - name: Detect status token
        id: detect-finalize-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Final status skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; final commit status omitted.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Update commit status with result
        if: ${{ env.TARGET_SHA != '' && steps.detect-finalize-token.outputs.available == 'true' }}
        uses: actions/github-script@v7
        env:
          TARGET_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          MAC_RESULT: ${{ needs.build-macos.result }}
          WIN_RESULT: ${{ needs.build-windows.result }}
        with:
          github-token: ${{ secrets.UPDATES_REPO_TOKEN }}
          script: |
            const [owner, repo] = process.env.PRIVATE_REPO.split('/');
            const sha = process.env.TARGET_SHA;
            const context = process.env.STATUS_CONTEXT;
            const targetUrl = process.env.TARGET_URL;
            const results = [process.env.MAC_RESULT, process.env.WIN_RESULT];
            const allSucceeded = results.every((r) => r === 'success' || r === 'skipped');

            const state = allSucceeded ? 'success' : 'failure';
            const description = allSucceeded
              ? (context.endsWith('release') ? 'Public release build succeeded' : 'Public CI build succeeded')
              : 'Public build failed — see logs in rostoc-updates repo';

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state,
              context,
              description,
              target_url: targetUrl
            });

            core.info(`Set ${state} status (${context}) on ${owner}/${repo}@${sha}`);
