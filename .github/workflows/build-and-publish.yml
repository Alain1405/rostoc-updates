name: Build Rostoc Core

on:
  workflow_call:
    inputs:
      ref:
        description: "Branch, tag, or SHA to build from private repo"
        required: false
        type: string
        default: "main"
      commit_sha:
        description: "Commit SHA of the private repo (for stamping)"
        required: false
        type: string
      initiator:
        description: "Who triggered the run (for logging/summaries)"
        required: false
        type: string
      is_release:
        description: "Whether to execute release publishing steps"
        required: true
        type: boolean
  workflow_dispatch:
    inputs:
      ref:
        description: "Branch, tag, or SHA to build from private repo"
        required: false
        default: "main"
      commit_sha:
        description: "Commit SHA of the private repo (for stamping)"
        required: false
      initiator:
        description: "Who triggered the run (for logging/summaries)"
        required: false
      is_release:
        description: "Whether to execute release publishing steps"
        required: true
        type: boolean
        default: false

permissions:
  contents: write # Push updates to this repo / checkout private repo
  pages: write # Deploy Pages when releasing
  id-token: write # OIDC for Pages when releasing

env:
  PRIVATE_REPO: alain1405/rostoc
  UPDATES_DIR: updates
  VERSION_FILE: version.txt
  PYTAURI_GEN_TS: 0
  LC_ALL: en_US.UTF-8
  LANG: en_US.UTF-8
  LC_CTYPE: en_US.UTF-8

jobs:
  set-status:
    runs-on: ubuntu-latest
    env:
      TARGET_SHA: ${{ inputs.commit_sha || github.sha }}
      STATUS_CONTEXT: ${{ inputs.is_release && 'rostoc-updates/release' || 'rostoc-updates/ci' }}
      STATUS_DESCRIPTION: ${{ inputs.is_release && 'Public release build running' || 'Public CI build running' }}
    steps:
      - name: Detect status token
        id: detect-status-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Status updates skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; omitting private repo commit status.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Set pending status in private repo
        if: ${{ env.TARGET_SHA != '' && steps.detect-status-token.outputs.available == 'true' }}
        uses: actions/github-script@v7
        env:
          TARGET_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          github-token: ${{ secrets.UPDATES_REPO_TOKEN }}
          result-encoding: string
          script: |
            const [owner, repo] = process.env.PRIVATE_REPO.split('/');
            const sha = process.env.TARGET_SHA;
            const context = process.env.STATUS_CONTEXT;
            const description = process.env.STATUS_DESCRIPTION;
            const targetUrl = process.env.TARGET_URL;

            if (!owner || !repo) {
              core.warning(`Unable to parse PRIVATE_REPO env "${process.env.PRIVATE_REPO}"; skipping status update.`);
              return 'skipped';
            }

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state: 'pending',
              context,
              description,
              target_url: targetUrl
            });

            core.info(`Set pending status (${context}) on ${owner}/${repo}@${sha}`);
            return 'pending-set';

  lint-and-tests:
    needs: set-status
    runs-on: ubuntu-latest
    timeout-minutes: 25
    steps:
      - name: Setup SSH agent for private repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}

      - name: Add GitHub to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout private repo (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable Corepack (pnpm)
        run: corepack enable

      - name: Derive pnpm store path
        id: verify-pnpm-store
        shell: bash
        run: |
          set -euo pipefail
          cd private-src
          echo "[INFO] pnpm version: $(pnpm --version || true)" >&2
          STORE_PATH=$(pnpm store path 2>/dev/null | tr -d '\r' || true)
          if [ -z "${STORE_PATH}" ]; then
            echo "[WARN] pnpm store path empty; falling back to default ~/.pnpm-store" >&2
            STORE_PATH="$HOME/.pnpm-store"
          fi
          mkdir -p "$STORE_PATH" || true
          echo "Using STORE_PATH=$STORE_PATH" >&2
          echo "STORE_PATH=$STORE_PATH" >> "$GITHUB_OUTPUT"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.verify-pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ hashFiles('private-src/pnpm-lock.yaml') }}
          restore-keys: pnpm-${{ runner.os }}-

      - name: Install uv (Python package manager)
        working-directory: private-src
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          echo "UV_BIN=$HOME/.local/bin" >> $GITHUB_ENV

      - name: Cache Python wheels
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.cache/uv
          key: python-wheel-${{ runner.os }}-${{ hashFiles('private-src/uv.lock') }}
          restore-keys: |
            python-wheel-${{ runner.os }}-

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust target
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: private-src
          shared-key: lint
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Install JS dependencies
        working-directory: private-src
        run: pnpm install --frozen-lockfile

      - name: Run lint suite
        working-directory: private-src
        run: pnpm lint

      - name: Run smoke tests
        working-directory: private-src
        env:
          REQUIRE_ROSI: "0"
          CORO_ROSI_DISABLED: "1"
        run: pnpm smoke

  build-macos:
    needs:
      - set-status
      - lint-and-tests
    runs-on: macos-14
    env:
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
      SENTRY_SEND_DEFAULT_PII: ${{ secrets.SENTRY_SEND_DEFAULT_PII }}
      SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
      VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
      VITE_SENTRY_SEND_DEFAULT_PII: ${{ secrets.VITE_SENTRY_SEND_DEFAULT_PII }}
      VITE_SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
    timeout-minutes: 50
    outputs:
      version: ${{ steps.extract_version.outputs.version }}
      tarball: ${{ steps.prepare_artifacts.outputs.tarball }}
      signature: ${{ steps.prepare_artifacts.outputs.signature }}
    steps:
      # --- Checkout this updates repo ---
      - name: Checkout updates repo
        if: inputs.is_release
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: updates-repo

      # --- SSH method to read the private repo ---
      - name: Setup SSH agent for private repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}

      - name: Add GitHub to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout private repo (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src
          fetch-depth: 0
          sparse-checkout: |
            /*
            !/references/
          sparse-checkout-cone-mode: false

      - name: Capture release version
        if: inputs.is_release
        shell: bash
        run: |
          set -euo pipefail
          REF="${{ inputs.ref }}"
          VERSION=${REF#v}
          if [[ -z "$VERSION" ]]; then
            echo "::error::Unable to derive release version from ref '$REF'" >&2
            exit 1
          fi
          echo "RELEASE_VERSION=$VERSION" >> "$GITHUB_ENV"

      # --- Setup toolchains ---
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable Corepack (pnpm)
        run: corepack enable

      - name: Derive pnpm store path
        id: pnpm-store
        shell: bash
        run: |
          set -euo pipefail
          cd private-src
          echo "[INFO] pnpm version: $(pnpm --version || true)" >&2
          STORE_PATH=$(pnpm store path 2>/dev/null | tr -d '\r' || true)
          if [ -z "${STORE_PATH}" ]; then
            echo "[WARN] pnpm store path empty; falling back to default ~/.pnpm-store" >&2
            STORE_PATH="$HOME/.pnpm-store"
          fi
          mkdir -p "$STORE_PATH" || true
          echo "Using STORE_PATH=$STORE_PATH" >&2
          echo "STORE_PATH=$STORE_PATH" >> "$GITHUB_OUTPUT"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ hashFiles('private-src/pnpm-lock.yaml') }}
          restore-keys: pnpm-${{ runner.os }}-

      - name: Install uv (Python package manager)
        working-directory: private-src
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "UV_BIN=$HOME/.local/bin" >> $GITHUB_ENV
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache Python wheels
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/Library/Caches/pip
            ~/.cache/uv
            ~/Library/Caches/uv
          key: python-wheel-${{ runner.os }}-${{ hashFiles('private-src/uv.lock') }}
          restore-keys: |
            python-wheel-${{ runner.os }}-

      - name: Install Apple signing certificate
        working-directory: private-src
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail
          scripts/macos/install_signing_certificate.sh

      - name: Debug signing keychain state
        if: always()
        working-directory: private-src
        shell: bash
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail
          echo "[DEBUG] Listing configured keychains" >&2
          security list-keychains || true
          echo "[DEBUG] Available signing identities" >&2
          security find-identity -v -p codesigning || true
          if [ -n "${APPLE_SIGNING_IDENTITY:-}" ]; then
            echo "[DEBUG] Matching certificate summary for ${APPLE_SIGNING_IDENTITY}" >&2
            security find-certificate -Z -a -c "$APPLE_SIGNING_IDENTITY" 2>/dev/null | grep -E 'SHA-1|SHA-256|"' || true
          else
            echo "[DEBUG] APPLE_SIGNING_IDENTITY not provided" >&2
          fi

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies and build artifacts
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: private-src
          shared-key: macos
          save-if: ${{ github.ref == 'refs/heads/main' }}

      # --- Build Rostoc ---
      - name: Download embedded Python
        working-directory: private-src
        run: bash scripts/macos/download-py.sh

      - name: Install JS dependencies
        working-directory: private-src
        run: pnpm install --frozen-lockfile

      - name: Stamp build version
        working-directory: private-src
        env:
          GITHUB_SHA: ${{ inputs.commit_sha || github.sha }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          set -euo pipefail
          if [[ -n "${RELEASE_VERSION:-}" ]]; then
            scripts/ci/stamp_dev_version.sh --version "$RELEASE_VERSION"
          else
            scripts/ci/stamp_dev_version.sh
          fi

      - name: Extract version
        id: extract_version
        working-directory: private-src
        run: |
          set -euo pipefail
          VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "[INFO] Building version: $VERSION"
          echo "SENTRY_RELEASE=rostoc@$VERSION" >> "$GITHUB_ENV"
          echo "VITE_SENTRY_RELEASE=rostoc@$VERSION" >> "$GITHUB_ENV"
          echo "APP_VERSION=$VERSION" >> "$GITHUB_ENV"

      - name: Apply preview build tuning (no-release)
        if: ${{ !inputs.is_release }}
        working-directory: private-src
        shell: bash
        run: scripts/ci/apply_preview_rust_env.sh

      - name: Build application (with signing)
        working-directory: private-src
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          ALLOW_PARTIAL_BUNDLE: 1
          ENABLE_RUNTIME_CACHE: "1"
          UV_DISABLE_WORKSPACE: "1"
          UV_PROJECT_ENVIRONMENT: "shared"
        run: |
          set -euo pipefail
          echo "[INFO] Starting build - output will be saved to build-macos.log"
          python scripts/build.py --locked 2>&1 | tee build-macos.log

      - name: Sign DMG
        working-directory: private-src
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail
          
          # Find the DMG file
          DMG_PATH=$(find target/release/bundle/dmg -name "*.dmg" -type f | head -n 1)
          
          if [ -z "$DMG_PATH" ]; then
            echo "::error::No DMG file found in target/release/bundle/dmg"
            exit 1
          fi
          
          echo "[INFO] Found DMG: $DMG_PATH"
          echo "[INFO] Signing DMG with identity: $APPLE_SIGNING_IDENTITY"
          
          # Sign the DMG
          codesign --sign "$APPLE_SIGNING_IDENTITY" \
                   --force \
                   --verbose \
                   --timestamp \
                   --options runtime \
                   "$DMG_PATH"
          
          # Verify the signature
          echo "[INFO] Verifying DMG signature"
          codesign --verify --deep --strict --verbose=2 "$DMG_PATH"
          
          echo "[INFO] DMG signed successfully"

      - name: Notarize macOS bundle
        working-directory: private-src
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail
          if ! command -v xcrun >/dev/null 2>&1; then
            echo "::error::xcrun not available on runner"
            exit 1
          fi

          echo "[DEBUG] Notarization env availability summary:"
          for var in APPLE_ID APPLE_APP_SPECIFIC_PASSWORD APPLE_TEAM_ID APPLE_SIGNING_IDENTITY; do
            if [[ -n "${!var:-}" ]]; then
              echo "  - ${var}: present"
            else
              echo "  - ${var}: MISSING"
            fi
          done

          if [[ -z "${APPLE_ID:-}" || -z "${APPLE_APP_SPECIFIC_PASSWORD:-}" || -z "${APPLE_TEAM_ID:-}" ]]; then
            echo "::error::Notarization credentials missing (APPLE_ID / APPLE_APP_SPECIFIC_PASSWORD / APPLE_TEAM_ID)"
            exit 1
          fi
          SEARCH_DIRS=(
            target/bundle-release/bundle/macos
            src-tauri/target/bundle-release/bundle/macos
            target/release/bundle/macos
            src-tauri/target/release/bundle/macos
          )
          ABS_APP=""
          for dir in "${SEARCH_DIRS[@]}"; do
            if [[ -d "$dir" ]]; then
              found=$(find "$dir" -maxdepth 1 -type d -name '*.app' -print -quit 2>/dev/null || true)
              if [[ -n "$found" ]]; then
                if [[ "$found" != /* ]]; then
                  ABS_APP="$GITHUB_WORKSPACE/private-src/$found"
                else
                  ABS_APP="$found"
                fi
                break
              fi
            fi
          done

          if [[ -z "$ABS_APP" ]]; then
            echo "::error::No app bundle located for notarization"
            for dir in "${SEARCH_DIRS[@]}"; do
              if [[ -d "$dir" ]]; then
                echo "[DEBUG] Contents of $dir" >&2
                ls -al "$dir" || true
              else
                echo "[DEBUG] Missing directory: $dir" >&2
              fi
            done
            exit 1
          fi
          if [[ ! -d "$ABS_APP" ]]; then
            echo "::error::Resolved app bundle path does not exist: $ABS_APP"
            exit 1
          fi

          echo "[INFO] Preparing app for notarization: ${ABS_APP}"
          DMG_PATH=$(find target -maxdepth 5 -type f -name '*.dmg' -print -quit || true)
          if [[ -z "${DMG_PATH}" ]]; then
            echo "[WARN] DMG not found, creating temporary zip for notarization"
            TMP_ZIP="$(pwd)/notarize_app.zip"
            rm -f "$TMP_ZIP"
            ditto -c -k --keepParent "${ABS_APP}" "$TMP_ZIP"
            NOTARIZE_PAYLOAD="$TMP_ZIP"
            NOTARIZE_TYPE="bundle (zip)"
          else
            if [[ "${DMG_PATH}" != /* ]]; then
              DMG_PATH="$GITHUB_WORKSPACE/private-src/${DMG_PATH}"
            fi
            NOTARIZE_PAYLOAD="$DMG_PATH"
            NOTARIZE_TYPE="dmg"
          fi

          echo "[INFO] Notarizing ${NOTARIZE_TYPE}: ${NOTARIZE_PAYLOAD}"
          echo "[DEBUG] Listing payload contents"
          if [[ "${NOTARIZE_TYPE}" == "dmg" ]]; then
            hdiutil imageinfo "${NOTARIZE_PAYLOAD}" || true
          else
            unzip -l "${NOTARIZE_PAYLOAD}" || true
          fi

          echo "[INFO] Submitting to Apple notarization service (non-blocking)"
          NOTARIZATION_LOG="notarization-submission-${GITHUB_RUN_ID}.log"
          SUBMISSION_OUTPUT=$(xcrun notarytool submit "${NOTARIZE_PAYLOAD}" \
            --apple-id "${APPLE_ID}" \
            --team-id "${APPLE_TEAM_ID}" \
            --password "${APPLE_APP_SPECIFIC_PASSWORD}" \
            --no-wait \
            --output-format json 2>&1) || {
            NOTARY_STATUS=$?
            echo "::error::Notarization submission failed with status ${NOTARY_STATUS}"
            echo "$SUBMISSION_OUTPUT" | tee "${NOTARIZATION_LOG}"
            exit 1
          }

          echo "$SUBMISSION_OUTPUT" | tee "${NOTARIZATION_LOG}"

          # Extract submission ID from JSON output
          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | jq -r '.id // empty')
          if [[ -z "$SUBMISSION_ID" ]]; then
            echo "::error::Failed to extract submission ID from notarytool output"
            echo "$SUBMISSION_OUTPUT"
            exit 1
          fi

          echo "[INFO] Notarization submitted successfully. ID: ${SUBMISSION_ID}"
          echo "[INFO] Notarization will complete asynchronously. DMG will be stapled and uploaded by scheduled workflow."

          # Save pending notarization details for stapling workflow
          PENDING_FILE="pending-notarizations.csv"
          DMG_FILENAME=$(basename "${DMG_PATH}")
          RELEASE_TAG="${{ steps.extract_version.outputs.version }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          echo "submission_id,dmg_filename,release_tag,dmg_path,submitted_at" > "${PENDING_FILE}"
          echo "${SUBMISSION_ID},${DMG_FILENAME},${RELEASE_TAG},${DMG_PATH},${TIMESTAMP}" >> "${PENDING_FILE}"

          echo "[INFO] Saved pending notarization metadata to ${PENDING_FILE}"
          cat "${PENDING_FILE}"

          if [[ "${NOTARIZE_TYPE}" == "bundle (zip)" && -n "${TMP_ZIP:-}" ]]; then
            echo "[DEBUG] Removing temporary notarization payload: ${TMP_ZIP}"
            rm -f "${TMP_ZIP}" || true
          fi

      - name: Upload notarization logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macos-notarization-logs
          path: private-src/notarization-*.log
          if-no-files-found: ignore

      - name: Upload pending notarizations metadata
        uses: actions/upload-artifact@v4
        with:
          name: pending-notarizations
          path: |
            private-src/pending-notarizations.csv
            private-src/target/**/*.dmg
          if-no-files-found: warn

      - name: Verify app bundle
        working-directory: private-src
        run: bash scripts/verify_app_bundle.sh

      - name: Locate macOS app bundle
        id: locate_macos_bundle
        working-directory: private-src
        run: |
          set -euo pipefail
          SEARCH_DIRS=(target/bundle-release/bundle/macos src-tauri/target/bundle-release/bundle/macos src-tauri/target/release/bundle/macos target/release/bundle/macos)
          APP_PATH=""
          for dir in "${SEARCH_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              cand=$(find "$dir" -maxdepth 1 -type d -name '*.app' -print -quit 2>/dev/null || true)
              if [ -n "$cand" ]; then
                APP_PATH="$cand"
                break
              fi
            fi
          done
          if [ -z "$APP_PATH" ]; then
            echo "::error::No .app bundle located in expected directories"
            for dir in "${SEARCH_DIRS[@]}"; do
              if [ -d "$dir" ]; then
                echo "[INFO] Contents of $dir:"
                ls -al "$dir"
              else
                echo "[INFO] Missing search dir: $dir"
              fi
            done
            exit 1
          fi
          # Use canonical path from runtime_config
          PYTHON_PATH=$(python3 scripts/ci/get_runtime_path.py python_path unix)
          MACOS_RES=$(python3 scripts/ci/get_runtime_path.py macos_resources)
          PYBIN="$APP_PATH/$MACOS_RES/$PYTHON_PATH"
          APP_PARENT=$(dirname "$APP_PATH")
          APP_NAME=$(basename "$APP_PATH")
          echo "app_path=$APP_PATH" >> "$GITHUB_OUTPUT"
          echo "bundle_dir=$APP_PARENT" >> "$GITHUB_OUTPUT"
          echo "app_name=$APP_NAME" >> "$GITHUB_OUTPUT"
          echo "python_path=$PYBIN" >> "$GITHUB_OUTPUT"
          if [ ! -x "$PYBIN" ]; then
            echo "::error::Embedded python binary not found at canonical location: $PYBIN"
            exit 1
          fi

      - name: Runtime smoke test (mac)
        if: steps.locate_macos_bundle.outputs.app_path != ''
        working-directory: private-src
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
          PYBIN_HINT: ${{ steps.locate_macos_bundle.outputs.python_path }}
        run: |
          set -euo pipefail
          if [ -z "${APP_BUNDLE}" ]; then
            echo '::error::app_path output missing from locate step'
            exit 1
          fi
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "::error::Resolved app bundle directory not found: $ABS_APP"
            ls -al "$GITHUB_WORKSPACE/private-src"
            exit 1
          fi
          PYBIN="${PYBIN_HINT}"
          if [[ -n "$PYBIN" && "$PYBIN" != /* ]]; then
            PYBIN="$GITHUB_WORKSPACE/private-src/$PYBIN"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            echo '::error::Embedded python3 not found at canonical location'
            exit 1
          fi
          echo "[INFO] Running runtime smoke test: $PYBIN"
          "$PYBIN" scripts/ci/unified_smoke_validator.py runtime \
            --platform mac \
            --comprehensive \
            --require-manifest \
            --debug-json macos_runtime_smoke_debug.json

      - name: Dump macOS codesign diagnostics
        if: steps.locate_macos_bundle.outputs.app_path != ''
        working-directory: private-src
        shell: bash
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
        run: |
          set -euo pipefail
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "[DEBUG] App bundle not found for codesign diagnostics: $ABS_APP" >&2
            exit 0
          fi
          echo "[DEBUG] codesign -dv --verbose=4 output" >&2
          codesign -dv --verbose=4 "$ABS_APP" 2>&1 || true
          echo "[DEBUG] codesign --verify --deep --strict output" >&2
          codesign --verify --deep --strict "$ABS_APP" 2>&1 || true
          if command -v spctl >/dev/null 2>&1; then
            echo "[DEBUG] spctl assessment" >&2
            spctl --assess --type exec "$ABS_APP" 2>&1 || true
          fi

      - name: GUI smoke test (non-fatal)
        if: always()
        working-directory: private-src
        shell: bash
        env:
          PYBIN_HINT: ${{ steps.locate_macos_bundle.outputs.python_path }}
        run: |
          set -euo pipefail
          ABS_APP="${{ steps.locate_macos_bundle.outputs.app_path }}"
          if [ -z "$ABS_APP" ]; then
            echo "[WARN] No app bundle found, skipping GUI smoke test"
            exit 0
          fi
          PYBIN="${PYBIN_HINT}"
          if [[ -n "$PYBIN" && "$PYBIN" != /* ]]; then
            PYBIN="$GITHUB_WORKSPACE/private-src/$PYBIN"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            # Use canonical path from runtime_config
            PYTHON_PATH=$(python3 scripts/ci/get_runtime_path.py python_path unix)
            MACOS_RES=$(python3 scripts/ci/get_runtime_path.py macos_resources)
            PYBIN="$ABS_APP/$MACOS_RES/$PYTHON_PATH"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            echo "[WARN] Embedded python3 not found at canonical location, skipping GUI smoke test"
            exit 0
          fi
          echo "[INFO] Running GUI smoke test with 10s timeout"
          "$PYBIN" scripts/ci/unified_smoke_validator.py gui \
            --platform mac \
            --timeout 10 \
            --exe-path "$ABS_APP" \
            --debug-json macos_gui_smoke_debug.json \
            --strict

      - name: Upload macOS smoke diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macos-smoke-debug
          path: |
            private-src/macos_runtime_smoke_debug.json
            private-src/macos_gui_smoke_debug.json
          if-no-files-found: warn

      - name: Upload macOS build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macos-build-logs
          path: |
            private-src/build-macos.log
          if-no-files-found: warn

      - name: Archive macOS preview artifacts
        if: steps.locate_macos_bundle.outputs.app_path != ''
        id: archive_macos_preview
        working-directory: private-src
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
          BUNDLE_DIR: ${{ steps.locate_macos_bundle.outputs.bundle_dir }}
          APP_NAME: ${{ steps.locate_macos_bundle.outputs.app_name }}
          IS_RELEASE: ${{ inputs.is_release }}
        run: |
          set -euo pipefail
          if [ -z "${APP_BUNDLE}" ] || [ -z "${BUNDLE_DIR}" ] || [ -z "${APP_NAME}" ]; then
            echo "::error::Missing bundle metadata from locate_macos_bundle step"
            exit 1
          fi
          if [[ "${BUNDLE_DIR}" == /* ]]; then
            ABS_BUNDLE_DIR="${BUNDLE_DIR}"
          else
            ABS_BUNDLE_DIR="$GITHUB_WORKSPACE/private-src/${BUNDLE_DIR}"
          fi
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_BUNDLE_DIR" ]; then
            echo "::error::Bundle directory not found: $ABS_BUNDLE_DIR"
            exit 1
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "::error::App bundle not found: $ABS_APP"
            ls -al "$ABS_BUNDLE_DIR"
            exit 1
          fi
          if [ "${APP_NAME}" != "$(basename "$ABS_APP")" ]; then
            echo "::warning::App name output (${APP_NAME}) did not match bundle basename ($(basename "$ABS_APP"))"
          fi
          if [ "${IS_RELEASE}" != "true" ]; then
            codesign --force --deep -s - "$ABS_APP" || echo "Ad-hoc codesign failed (continuing)"
          fi
          tar -czf coro-macos-build-preview.tar.gz -C "$ABS_BUNDLE_DIR" "$APP_NAME"
          ditto -c -k --sequesterRsrc --keepParent "$ABS_APP" coro-macos-build-preview.zip || echo "ditto zip failed"

      - name: Upload macOS preview artifacts
        if: steps.archive_macos_preview.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: macos-preview
          path: |
            private-src/coro-macos-build-preview.tar.gz
            private-src/coro-macos-build-preview.zip
          if-no-files-found: ignore

      - name: Detect release upload token
        if: inputs.is_release
        id: detect-release-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Release asset upload skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; skipping release artifact upload.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Locate updater artifacts
        id: locate
        working-directory: private-src
        run: |
          set -euo pipefail
          # Prefer bundle-release profile artifacts, but search all known bundle directories.
          SEARCH_DIRS=(
            target/bundle-release/bundle/macos
            src-tauri/target/bundle-release/bundle/macos
            target/release/bundle/macos
            src-tauri/target/release/bundle/macos
          )

          TARBALL=""
          for dir in "${SEARCH_DIRS[@]}"; do
            [[ -d "$dir" ]] || continue
            cand=$(find "$dir" -maxdepth 1 -name 'Rostoc.app.tar.gz' -print -quit 2>/dev/null || true)
            if [[ -z "$cand" ]]; then
              cand=$(find "$dir" -maxdepth 1 -name 'Coro.app.tar.gz' -print -quit 2>/dev/null || true)
            fi
            if [[ -z "$cand" ]]; then
              cand=$(find "$dir" -maxdepth 1 -name '*.app.tar.gz' -print -quit 2>/dev/null || true)
            fi
            if [[ -n "$cand" ]]; then
              TARBALL="$cand"
              break
            fi
          done

          SIG_FILE=""
          if [[ -n "$TARBALL" ]]; then
            SIG_FILE="${TARBALL}.sig"
            if [[ ! -f "$SIG_FILE" ]]; then
              # Some bundler versions emit the signature alongside the tarball but do not use the simple .sig suffix.
              ALT_SIG=$(find "$(dirname "$TARBALL")" -maxdepth 1 -name "$(basename "$TARBALL").sig" -print -quit 2>/dev/null || true)
              if [[ -n "$ALT_SIG" ]]; then
                SIG_FILE="$ALT_SIG"
              fi
            fi
          fi

          echo "Tarball: $TARBALL" >&2
          echo "Signature: $SIG_FILE" >&2

          if [[ -z "$TARBALL" ]]; then
            echo 'Missing updater tarball (.app.tar.gz)'
            for dir in "${SEARCH_DIRS[@]}"; do
              if [[ -d "$dir" ]]; then
                echo "[INFO] Contents of $dir:" >&2
                ls -al "$dir" >&2
              else
                echo "[INFO] Missing search dir: $dir" >&2
              fi
            done
            exit 1
          fi
          if [[ -z "$SIG_FILE" || ! -f "$SIG_FILE" ]]; then
            echo 'Missing updater signature (.app.tar.gz.sig)'
            exit 1
          fi

          echo "tarball=$TARBALL" >> "$GITHUB_OUTPUT"
          echo "signature=$SIG_FILE" >> "$GITHUB_OUTPUT"

      - name: Prepare update bundle
        id: prepare_artifacts
        working-directory: private-src
        run: |
          set -euo pipefail
          TARBALL="${{ steps.locate.outputs.tarball }}"
          SIGNATURE="${{ steps.locate.outputs.signature }}"
          VERSION="${{ steps.extract_version.outputs.version }}"

          # Create updates directory
          mkdir -p "../${{ env.UPDATES_DIR }}/macos"

          # Copy artifacts with version-tagged names
          TARBALL_NAME="Rostoc-${VERSION}-darwin-aarch64.app.tar.gz"
          cp "$TARBALL" "../${{ env.UPDATES_DIR }}/macos/$TARBALL_NAME"
          cp "$SIGNATURE" "../${{ env.UPDATES_DIR }}/macos/${TARBALL_NAME}.sig"

          # Also copy as latest for convenience
          cp "$TARBALL" "../${{ env.UPDATES_DIR }}/macos/Rostoc.app.tar.gz"
          cp "$SIGNATURE" "../${{ env.UPDATES_DIR }}/macos/Rostoc.app.tar.gz.sig"

          # Stamp version file
          date -u +"%Y-%m-%dT%H:%M:%SZ" > "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"
          echo "version=${VERSION}" >> "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"
          echo "git_sha=$(git rev-parse --short HEAD)" >> "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"

          # Generate checksums
          (cd "../${{ env.UPDATES_DIR }}/macos" && shasum -a 256 *.tar.gz > checksums.txt)

          echo "tarball_name=$TARBALL_NAME" >> $GITHUB_OUTPUT

      - name: Upload release assets to private repo
        if: inputs.is_release && steps.detect-release-token.outputs.available == 'true'
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.UPDATES_REPO_TOKEN }}
          owner: alain1405
          repo: rostoc
          tag: ${{ inputs.ref }}
          draft: true
          allowUpdates: true
          artifacts: |
            updates/macos/Rostoc.app.tar.gz
            updates/macos/Rostoc.app.tar.gz.sig
            updates/version.txt
          artifactContentType: application/octet-stream

      - name: Upload artifacts for Pages deployment
        if: inputs.is_release
        uses: actions/upload-artifact@v4
        with:
          name: rostoc-updates
          path: ${{ env.UPDATES_DIR }}/*

  build-windows:
    needs:
      - set-status
      - lint-and-tests
    runs-on: windows-2022
    env:
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
      SENTRY_SEND_DEFAULT_PII: ${{ secrets.SENTRY_SEND_DEFAULT_PII }}
      SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
      VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
      VITE_SENTRY_SEND_DEFAULT_PII: ${{ secrets.VITE_SENTRY_SEND_DEFAULT_PII }}
      VITE_SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
    timeout-minutes: 45
    outputs:
      version: ${{ steps.extract_version_win.outputs.version }}
      installer_name: ${{ inputs.is_release && steps.prepare_windows_updates.outputs.versioned_name || '' }}
      installer_latest: ${{ inputs.is_release && steps.prepare_windows_updates.outputs.latest_name || '' }}
      installer_checksum: ${{ inputs.is_release && steps.prepare_windows_updates.outputs.checksum || '' }}
    steps:
      - name: Setup SSH agent for private repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}

      - name: Add GitHub to known_hosts
        shell: bash
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout private repo (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src
          fetch-depth: 0

      - name: Capture release version
        if: inputs.is_release
        shell: bash
        run: |
          set -euo pipefail
          REF="${{ inputs.ref }}"
          VERSION=${REF#v}
          if [[ -z "$VERSION" ]]; then
            echo "::error::Unable to derive release version from ref '$REF'" >&2
            exit 1
          fi
          echo "RELEASE_VERSION=$VERSION" >> "$GITHUB_ENV"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable Corepack (pnpm)
        run: corepack enable

      - name: Derive pnpm store path
        id: windows-pnpm-store
        shell: bash
        run: |
          set -euo pipefail
          cd private-src
          echo "[INFO] pnpm version: $(pnpm --version || true)" >&2
          STORE_PATH=$(pnpm store path 2>/dev/null | tr -d '\r' || true)
          if [ -z "${STORE_PATH}" ]; then
            echo "[WARN] pnpm store path empty; falling back to default ~/.pnpm-store" >&2
            STORE_PATH="$HOME/.pnpm-store"
          fi
          mkdir -p "$STORE_PATH" || true
          echo "Using STORE_PATH=$STORE_PATH" >&2
          echo "STORE_PATH=$STORE_PATH" >> "$GITHUB_OUTPUT"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.windows-pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ hashFiles('private-src/pnpm-lock.yaml') }}
          restore-keys: pnpm-${{ runner.os }}-

      - name: Cache Python wheels
        uses: actions/cache@v4
        with:
          path: |
            ~\AppData\Local\pip\Cache
            ~\.cache\pip
            ~\AppData\Local\uv
          key: python-wheel-${{ runner.os }}-${{ hashFiles('private-src/uv.lock') }}
          restore-keys: |
            python-wheel-${{ runner.os }}-

      - name: Cache embedded Python
        uses: actions/cache@v4
        with:
          path: private-src/src-tauri/pyembed
          key: pyembed-${{ runner.os }}-${{ hashFiles('private-src/scripts/windows/download-py.ps1') }}
          restore-keys: |
            pyembed-${{ runner.os }}-

      - name: Cache WiX Tools
        uses: actions/cache@v4
        with:
          path: ~\AppData\Local\tauri\WixTools
          key: wix-tools-${{ runner.os }}-v314
          restore-keys: |
            wix-tools-${{ runner.os }}-

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install uv (Python helper)
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $script = Invoke-RestMethod -Uri 'https://astral.sh/uv/install.ps1'
          Invoke-Expression $script
          "$env:USERPROFILE\.local\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          Add-Content -Path $env:GITHUB_ENV -Value "UV_BIN=$($env:USERPROFILE)\.local\bin"

      - name: Cache Rust dependencies and build artifacts
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: private-src
          shared-key: windows
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Download embedded Python
        working-directory: private-src
        shell: pwsh
        run: scripts/windows/download-py.ps1

      - name: Install JS dependencies
        working-directory: private-src
        run: pnpm install --frozen-lockfile

      - name: Pre-fetch Cargo dependencies (locked)
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          if [ -f Cargo.lock ]; then
            cargo fetch --locked
          elif [ -f src-tauri/Cargo.lock ]; then
            cargo fetch --locked --manifest-path src-tauri/Cargo.toml
          else
            echo "::warning::No Cargo.lock found before stamping; lockfile stability not guaranteed"
          fi

      - name: Stamp build version
        working-directory: private-src
        shell: bash
        env:
          GITHUB_SHA: ${{ inputs.commit_sha || github.sha }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
          # Avoid hitting the network and accidentally relocking during stamping
          CARGO_NET_OFFLINE: true
        run: |
          set -euo pipefail
          if [[ -n "${RELEASE_VERSION:-}" ]]; then
            scripts/ci/stamp_dev_version.sh --version "$RELEASE_VERSION"
          else
            scripts/ci/stamp_dev_version.sh
          fi

      - name: Refresh Cargo.lock offline after stamping
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          # The stamping step updates the workspace member version in Cargo.toml,
          # which can require touching Cargo.lock even if deps didn't change.
          # Refresh the lockfile OFFLINE to avoid any dependency churn.
          if [ -f Cargo.lock ]; then
            manifest="Cargo.toml"
          elif [ -f src-tauri/Cargo.lock ]; then
            manifest="src-tauri/Cargo.toml"
          else
            echo "::notice::No Cargo.lock found to refresh; skipping"
            exit 0
          fi
          echo "[INFO] Regenerating lockfile offline for manifest: $manifest"
          cargo generate-lockfile --offline --manifest-path "$manifest"

      - name: Apply preview build tuning (no-release)
        if: ${{ !inputs.is_release }}
        working-directory: private-src
        shell: bash
        run: scripts/ci/apply_preview_rust_env.sh

      - name: Extract version
        id: extract_version_win
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $content = Get-Content src-tauri/tauri.conf.json -Raw | ConvertFrom-Json
          if (-not $content.version) {
            throw 'Version not found in src-tauri/tauri.conf.json'
          }
          "version=$($content.version)" >> $env:GITHUB_OUTPUT
          Add-Content -Path $env:GITHUB_ENV -Value "SENTRY_RELEASE=rostoc@$($content.version)"
          Add-Content -Path $env:GITHUB_ENV -Value "VITE_SENTRY_RELEASE=rostoc@$($content.version)"
          Add-Content -Path $env:GITHUB_ENV -Value "APP_VERSION=$($content.version)"

      - name: Build application (unified)
        working-directory: private-src
        shell: bash
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          ALLOW_PARTIAL_BUNDLE: 1
          ENABLE_RUNTIME_CACHE: "1"
          UV_DISABLE_WORKSPACE: "1"
          UV_PROJECT_ENVIRONMENT: "shared"
        run: |
          set -euo pipefail
          # Only purge PyO3 build artifacts for release builds; for preview keep them to improve cache reuse
          if [ "${{ inputs.is_release }}" = "true" ]; then
            find target -maxdepth 7 -name pyo3-build-config.txt -print -delete 2>/dev/null || true
            rm -rf target/release/build/pyo3* target/debug/build/pyo3* 2>/dev/null || true
          fi

          # Use consolidated build script (replaces assemble_runtime.py + pnpm tauri build + embed_windows_runtime.py)
          echo "[INFO] Starting build - output will be saved to build-windows.log"

          # Reduce WiX verbosity and skip some validation checks for faster builds
          export WIX_SUPPRESS_ICE="ICE61;ICE69"

          # For preview builds, skip installer creation (saves 3-5 minutes)
          # For release builds, only create MSI (skip NSIS for faster builds)
          BUILD_ARGS="--locked"
          if [ "${{ inputs.is_release }}" != "true" ]; then
            echo "[INFO] Preview build: skipping installer creation (no --bundles flag)"
          else
            BUILD_ARGS="$BUILD_ARGS --bundles msi"
            echo "[INFO] Release build: creating MSI installer only (NSIS skipped for speed)"
          fi

          # Retry logic to handle transient WiX download failures
          MAX_ATTEMPTS=3
          ATTEMPT=1
          BUILD_EXIT_CODE=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "[INFO] Build attempt $ATTEMPT of $MAX_ATTEMPTS"
            if python scripts/build.py $BUILD_ARGS 2>&1 | tee build-windows.log; then
              BUILD_EXIT_CODE=0
              break
            else
              BUILD_EXIT_CODE=${PIPESTATUS[0]}
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "[WARN] Build failed with exit code $BUILD_EXIT_CODE, retrying in 10 seconds..."
                sleep 10
              else
                echo "[ERROR] Build failed after $MAX_ATTEMPTS attempts"
              fi
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done

          exit $BUILD_EXIT_CODE

      - name: Check Python DLL linkage
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          # Support both tauri-bundled layout (target/...) and preview cargo build layout (src-tauri/target/...)
          EXE=$( (find target -type f -iname 'rostoc.exe' 2>/dev/null; find src-tauri/target -type f -iname 'rostoc.exe' 2>/dev/null) | head -n1 || true)
          if [ -z "$EXE" ]; then
            echo 'Rostoc.exe not found; available executables:' >&2
            find target -maxdepth 5 -type f -print || true
            find src-tauri/target -maxdepth 5 -type f -print || true
            exit 1
          fi
          echo "[INFO] Scanning for python DLL references in $EXE" >&2
          strings "$EXE" | grep -iE 'python3[0-9]+\.dll' | sort -u || echo '[WARN] No python3*.dll tokens found'
          if command -v objdump >/dev/null 2>&1; then
            objdump -p "$EXE" | grep -i 'DLL Name' | head -n 40 || true
          fi

      - name: Runtime smoke test
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          # Use canonical path from runtime_config
          PYTHON_PATH=$(python3 scripts/ci/get_runtime_path.py python_path windows)
          PYBIN=$(find target -type f -path "*/$PYTHON_PATH" -print -quit || true)
          if [ -z "$PYBIN" ]; then
            echo "::error::Embedded python.exe not found at canonical location: $PYTHON_PATH"
            exit 1
          fi
          echo "[INFO] Running runtime smoke test: $PYBIN" >&2
          "$PYBIN" scripts/ci/unified_smoke_validator.py runtime \
            --platform windows \
            --comprehensive \
            --require-manifest \
            --debug-json windows_runtime_smoke_debug.json \
            --strict

      - name: GUI smoke test
        if: always()
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          # Use canonical path from runtime_config
          PYTHON_PATH=$(python3 scripts/ci/get_runtime_path.py python_path windows)
          PYBIN=$(find target -type f -path "*/$PYTHON_PATH" -print -quit || true)
          if [ -z "$PYBIN" ]; then
            echo "[WARN] Embedded python.exe not found, skipping GUI smoke test" >&2
            exit 0
          fi
          # Find the exe that's in the same directory as pyembed (Windows: exe_parent/pyembed/python)
          PYEMBED_DIR=$(dirname "$PYBIN" | sed 's|/pyembed/python||')
          EXE="${PYEMBED_DIR}/rostoc.exe"
          if [ ! -f "$EXE" ]; then
            echo "[WARN] rostoc.exe not found at $EXE (same dir as pyembed), skipping GUI smoke test" >&2
            exit 0
          fi
          echo "[INFO] Running GUI smoke test with 10s timeout" >&2
          echo "[INFO] EXE: $EXE" >&2
          echo "[INFO] PYBIN: $PYBIN" >&2
          "$PYBIN" scripts/ci/unified_smoke_validator.py gui \
            --platform windows \
            --timeout 10 \
            --exe-path "$EXE" \
            --debug-json windows_gui_smoke_debug.json \
            --strict

      - name: Locate Windows MSI artifact (smoke)
        id: locate_windows_msi
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $searchRoots = @('target', 'src-tauri/target')
          $candidates = @()
          foreach ($root in $searchRoots) {
            if (-not (Test-Path -LiteralPath $root)) { continue }
            $found = Get-ChildItem -Path $root -Recurse -File -Filter '*.msi' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending
            if ($found) { $candidates += $found }
          }
          $msi = $candidates | Select-Object -First 1
          if (-not $msi) {
            throw 'MSI artifact not found under target/ or src-tauri/target/'
          }
          Write-Host "[INFO] Using MSI artifact: $($msi.FullName)"
          "msi_path=$($msi.FullName)" >> $env:GITHUB_OUTPUT

      - name: Install MSI for smoke test
        if: steps.locate_windows_msi.outcome == 'success'
        id: install_windows_msi
        working-directory: private-src
        shell: pwsh
        env:
          MSI_PATH: ${{ steps.locate_windows_msi.outputs.msi_path }}
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:MSI_PATH -or -not (Test-Path -LiteralPath $env:MSI_PATH)) {
            throw "MSI artifact missing at path '$env:MSI_PATH'"
          }
          $logPath = Join-Path $PWD 'windows_msi_install.log'
          $arguments = @('/i', $env:MSI_PATH, '/qn', '/norestart', '/log', $logPath)
          Write-Host "[INFO] Installing MSI via msiexec (log: $logPath)"
          $process = Start-Process -FilePath msiexec.exe -ArgumentList $arguments -Wait -PassThru
          if ($process.ExitCode -ne 0) {
            throw "msiexec exited with code $($process.ExitCode)"
          }
          Write-Host "[INFO] MSI installation completed"
          "install_log=$logPath" >> $env:GITHUB_OUTPUT

      - name: Locate installed Rostoc (MSI)
        if: steps.install_windows_msi.outcome == 'success'
        id: locate_installed_windows_msi
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          # Get canonical paths from runtime_config
          $exePath = & python3 scripts/ci/get_runtime_path.py msi_exe_path
          $expectedPyPath = & python3 scripts/ci/get_runtime_path.py msi_python_path

          Write-Host "[INFO] Checking MSI installation path (from runtime_config): $exePath"
          if (-not (Test-Path -LiteralPath $exePath)) {
            throw "MSI-installed rostoc.exe not found at expected location: $exePath"
          }
          Write-Host "[INFO] Found installed exe: $exePath"

          # Verify Python is at expected location (strict check - must be exactly here)
          Write-Host "[INFO] Verifying Python at expected location: $expectedPyPath"
          if (-not (Test-Path -LiteralPath $expectedPyPath)) {
            throw "Embedded python.exe not found at expected location: $expectedPyPath"
          }
          Write-Host "[INFO] Found installed pyembed python at expected location: $expectedPyPath"

          "installed_exe=$exePath" >> $env:GITHUB_OUTPUT
          "installed_py=$expectedPyPath" >> $env:GITHUB_OUTPUT

      - name: Runtime smoke test (MSI install)
        if: steps.locate_installed_windows_msi.outcome == 'success'
        working-directory: private-src
        shell: pwsh
        env:
          INSTALLED_PY: ${{ steps.locate_installed_windows_msi.outputs.installed_py }}
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:INSTALLED_PY -or -not (Test-Path -LiteralPath $env:INSTALLED_PY)) {
            throw "Installed embedded python not found at '$env:INSTALLED_PY'"
          }
          $script = Join-Path $PWD 'scripts\ci\unified_smoke_validator.py'
          & $env:INSTALLED_PY $script runtime `
            --platform windows `
            --comprehensive `
            --require-manifest `
            --debug-json windows_msi_runtime_smoke_debug.json `
            --strict

      - name: GUI smoke test (MSI install)
        if: always()
        working-directory: private-src
        shell: pwsh
        env:
          INSTALLED_EXE: ${{ steps.locate_installed_windows_msi.outputs.installed_exe }}
          INSTALLED_PY: ${{ steps.locate_installed_windows_msi.outputs.installed_py }}
        run: |
          $ErrorActionPreference = 'Continue'
          if (-not $env:INSTALLED_PY -or -not (Test-Path -LiteralPath $env:INSTALLED_PY)) {
            Write-Host '[WARN] Installed embedded python missing, skipping MSI GUI smoke test'
            exit 0
          }
          if (-not $env:INSTALLED_EXE -or -not (Test-Path -LiteralPath $env:INSTALLED_EXE)) {
            Write-Host '[WARN] Installed rostoc.exe missing, skipping MSI GUI smoke test'
            exit 0
          }
          Write-Host "[INFO] Running MSI GUI smoke test against $env:INSTALLED_EXE"
          $script = Join-Path $PWD 'scripts\ci\unified_smoke_validator.py'
          & $env:INSTALLED_PY $script gui `
            --platform windows `
            --timeout 10 `
            --exe-path $env:INSTALLED_EXE `
            --debug-json windows_msi_gui_smoke_debug.json `
            --strict

      - name: Uninstall MSI (cleanup)
        if: always()
        shell: pwsh
        env:
          MSI_PATH: ${{ steps.locate_windows_msi.outputs.msi_path }}
        run: |
          $ErrorActionPreference = 'Continue'
          if ($env:MSI_PATH -and (Test-Path -LiteralPath $env:MSI_PATH)) {
            Write-Host "[INFO] Uninstalling MSI package"
            $arguments = @('/x', $env:MSI_PATH, '/qn', '/norestart')
            $process = Start-Process -FilePath msiexec.exe -ArgumentList $arguments -Wait -PassThru
            if ($process.ExitCode -ne 0) {
              Write-Warning "msiexec uninstall exited with code $($process.ExitCode)"
            }
          } else {
            Write-Host '[INFO] No MSI path available for uninstall; skipping'
          }

      - name: Upload smoke diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-smoke-debug
          path: |
            private-src/windows_runtime_smoke_debug.json
            private-src/windows_gui_smoke_debug.json
            private-src/windows_msi_runtime_smoke_debug.json
            private-src/windows_msi_gui_smoke_debug.json
            private-src/windows_msi_install.log
          if-no-files-found: warn

      - name: Upload Windows build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-build-logs
          path: |
            private-src/build-windows.log
          if-no-files-found: warn

      - name: Archive Windows artifacts
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          # Support both tauri-bundled layout (target/...) and preview cargo build layout (src-tauri/target/...)
          $exe = Get-ChildItem -Path @('target','src-tauri/target') -Recurse -File -Filter 'rostoc.exe' -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $exe) { Write-Error 'No Rostoc.exe found for archiving'; exit 1 }
          $bindir = Split-Path -Parent $exe.FullName
          Write-Host "[INFO] Found exe at $($exe.FullName) (bindir=$bindir)"
          $stage = "windows_bundle_stage"
          if (Test-Path $stage) { Remove-Item $stage -Recurse -Force }
          New-Item -ItemType Directory -Path $stage | Out-Null
          Copy-Item $exe.FullName (Join-Path $stage $exe.Name)
          if (Test-Path (Join-Path $bindir 'resources')) {
            Copy-Item (Join-Path $bindir 'resources') (Join-Path $stage 'resources') -Recurse
          }
          $dllPatterns = @('python3*.dll','vcruntime140.dll','vcruntime140_1.dll')
          foreach ($pat in $dllPatterns) {
            $matches = Get-ChildItem -Path $bindir -Filter $pat -ErrorAction SilentlyContinue
            foreach ($m in $matches) {
              Copy-Item $m.FullName (Join-Path $stage $m.Name) -Force
              Write-Host "[INFO] Included DLL $($m.Name)"
            }
          }
          if (Test-Path build/runtime_staging/runtime_manifest.json) {
            Copy-Item build/runtime_staging/runtime_manifest.json windows_runtime_manifest.json -ErrorAction SilentlyContinue
          }
          $zipPath = 'coro-windows-bundle.zip'
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path (Join-Path $stage '*') -DestinationPath $zipPath -Force
          Write-Host "[INFO] Created $zipPath"

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-preview
          path: |
            private-src/coro-windows-bundle.zip
            private-src/windows_runtime_manifest.json
          if-no-files-found: error

      - name: Locate Windows updater artifacts
        if: inputs.is_release
        id: locate_windows_updater
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $patterns = @('*.msi', '*.msi.zip', '*setup*.exe', '*.exe', '*.zip')
          $selected = $null
          foreach ($pattern in $patterns) {
            $found = Get-ChildItem -Path target -Recurse -File -Filter $pattern -ErrorAction SilentlyContinue | Where-Object {
              $_.FullName -match 'bundle'
            } | Sort-Object LastWriteTime -Descending | Select-Object -First 1
            if ($found) {
              $selected = $found
              break
            }
          }
          if (-not $selected) {
            throw 'No Windows installer artifact found under target/'
          }
          $sigPath = "$($selected.FullName).sig"
          if (-not (Test-Path $sigPath)) {
            $sigCandidate = Get-ChildItem -Path $selected.DirectoryName -Filter "$($selected.BaseName)*.sig" -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($sigCandidate) {
              $sigPath = $sigCandidate.FullName
            } else {
              throw "Signature file not found for $($selected.Name)"
            }
          }
          "artifact=$($selected.FullName)" >> $env:GITHUB_OUTPUT
          "artifact_name=$($selected.Name)" >> $env:GITHUB_OUTPUT
          "signature=$sigPath" >> $env:GITHUB_OUTPUT

      - name: Prepare Windows update bundle
        if: inputs.is_release
        id: prepare_windows_updates
        working-directory: private-src
        shell: pwsh
        env:
          UPDATES_DIR: ${{ env.UPDATES_DIR }}
        run: |
          $ErrorActionPreference = 'Stop'
          $version = '${{ steps.extract_version_win.outputs.version }}'
          if ([string]::IsNullOrWhiteSpace($version)) {
            throw 'Version output missing from extract_version_win step'
          }
          $artifactPath = '${{ steps.locate_windows_updater.outputs.artifact }}'
          $signaturePath = '${{ steps.locate_windows_updater.outputs.signature }}'
          if ([string]::IsNullOrWhiteSpace($artifactPath) -or -not (Test-Path -LiteralPath $artifactPath)) {
            throw "Installer artifact '$artifactPath' missing"
          }
          if ([string]::IsNullOrWhiteSpace($signaturePath) -or -not (Test-Path -LiteralPath $signaturePath)) {
            throw "Signature file '$signaturePath' missing"
          }
          $artifact = Get-Item -LiteralPath $artifactPath
          $signature = Get-Item -LiteralPath $signaturePath
          $platform = 'windows-x86_64'
          $parent = Split-Path -Parent $PWD
          $updatesRoot = Join-Path $parent $env:UPDATES_DIR
          if (-not (Test-Path -LiteralPath $updatesRoot)) {
            New-Item -ItemType Directory -Path $updatesRoot | Out-Null
          }
          $windowsDir = Join-Path $updatesRoot 'windows'
          if (-not (Test-Path -LiteralPath $windowsDir)) {
            New-Item -ItemType Directory -Path $windowsDir | Out-Null
          }
          $extension = $artifact.Extension
          if ($artifact.Name -like '*.msi.zip' -or $artifact.Name -like '*.exe.zip') {
            $extension = '.zip'
          }
          if (-not $extension) {
            $extension = [System.IO.Path]::GetExtension($artifact.Name)
          }
          $versionedName = "Rostoc-$version-$platform$extension"
          $versionedPath = Join-Path $windowsDir $versionedName
          Copy-Item -LiteralPath $artifact.FullName -Destination $versionedPath -Force
          $sigTarget = "$versionedPath.sig"
          Copy-Item -LiteralPath $signature.FullName -Destination $sigTarget -Force
          $latestName = "Rostoc-$platform$extension"
          $latestPath = Join-Path $windowsDir $latestName
          Copy-Item -LiteralPath $artifact.FullName -Destination $latestPath -Force
          Copy-Item -LiteralPath $signature.FullName -Destination "$latestPath.sig" -Force
          $hash = Get-FileHash -Path $versionedPath -Algorithm SHA256
          $checksumPath = Join-Path $windowsDir 'checksums.txt'
          "$($hash.Hash)  $versionedName" | Out-File -FilePath $checksumPath -Encoding utf8
          "versioned_name=$versionedName" >> $env:GITHUB_OUTPUT
          "latest_name=$latestName" >> $env:GITHUB_OUTPUT
          "checksum=$($hash.Hash)" >> $env:GITHUB_OUTPUT

      - name: Upload artifacts for Pages deployment (Windows)
        if: inputs.is_release
        uses: actions/upload-artifact@v4
        with:
          name: rostoc-updates-windows
          path: updates/windows

  generate-releases-json:
    needs:
      - build-macos
      - build-windows
    if: inputs.is_release
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout main source repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: rostoc-updates
          path: macos-artifacts

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: rostoc-updates-windows
          path: windows-artifacts

      - name: Generate unified JSON manifests
        env:
          VERSION: ${{ needs.build-macos.outputs.version }}
        run: |
          set -euo pipefail
          echo "Generating releases.json and latest.json for version ${VERSION}"

          # Run the unified JSON generation script
          bash private-src/scripts/ci/generate_releases_json.sh \
            "${VERSION}" \
            "macos-artifacts" \
            "windows-artifacts" \
            "json-output"

          echo "Generated JSON files:"
          ls -lh json-output/
          echo ""
          echo "=== releases.json (first release entry) ==="
          jq '.releases[0]' json-output/releases.json
          echo ""
          echo "=== latest.json ==="
          cat json-output/latest.json

      - name: Upload JSON artifacts
        uses: actions/upload-artifact@v4
        with:
          name: releases-json
          path: json-output/*.json

  publish-to-pages:
    needs:
      - build-macos
      - build-windows
      - generate-releases-json
    if: inputs.is_release
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Checkout updates repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: rostoc-updates
          path: updates

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: rostoc-updates-windows
          path: updates/windows

      - name: Download JSON manifests
        uses: actions/download-artifact@v4
        with:
          name: releases-json
          path: updates

      - name: Commit & push updates (with version history)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add updates || true
          if ! git diff --cached --quiet; then
            git commit -m "chore: publish updates v${{ needs.build-macos.outputs.version }} ($(date -u +%F))"
            git push
          else
            echo "No changes to commit"
          fi

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: updates

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Summary
        run: |
          echo "## 🚀 Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          VERSION=""
          if [[ -f updates/version.txt ]]; then
            VERSION=$(grep -E '^version=' updates/version.txt | head -n 1 | cut -d'=' -f2- || true)
          fi
          if [[ -z "$VERSION" ]]; then
            VERSION='${{ needs.build-macos.outputs.version }}'
          fi
          echo "**Version:** ${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Updates URL:** https://alain1405.github.io/rostoc-updates/latest.json" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts:**" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ needs.build-macos.outputs.tarball }}" ]; then
            echo "- macOS artifact: macos/${{ needs.build-macos.outputs.tarball }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- macOS artifact: macos/Rostoc.app.tar.gz" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "${{ needs.build-windows.outputs.installer_name }}" ]; then
            echo "- Windows artifact: windows/${{ needs.build-windows.outputs.installer_name }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "**Pages URL:** ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY

  finalize-status:
    runs-on: ubuntu-latest
    needs:
      - build-macos
      - build-windows
    if: ${{ always() }}
    env:
      TARGET_SHA: ${{ inputs.commit_sha || github.sha }}
      STATUS_CONTEXT: ${{ inputs.is_release && 'rostoc-updates/release' || 'rostoc-updates/ci' }}
    steps:
      - name: Detect status token
        id: detect-finalize-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Final status skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; final commit status omitted.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Update commit status with result
        if: ${{ env.TARGET_SHA != '' && steps.detect-finalize-token.outputs.available == 'true' }}
        uses: actions/github-script@v7
        env:
          TARGET_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          MAC_RESULT: ${{ needs.build-macos.result }}
          WIN_RESULT: ${{ needs.build-windows.result }}
        with:
          github-token: ${{ secrets.UPDATES_REPO_TOKEN }}
          script: |
            const [owner, repo] = process.env.PRIVATE_REPO.split('/');
            const sha = process.env.TARGET_SHA;
            const context = process.env.STATUS_CONTEXT;
            const targetUrl = process.env.TARGET_URL;
            const results = [process.env.MAC_RESULT, process.env.WIN_RESULT];
            const allSucceeded = results.every((r) => r === 'success' || r === 'skipped');

            const state = allSucceeded ? 'success' : 'failure';
            const description = allSucceeded
              ? (context.endsWith('release') ? 'Public release build succeeded' : 'Public CI build succeeded')
              : 'Public build failed — see logs in rostoc-updates repo';

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state,
              context,
              description,
              target_url: targetUrl
            });

            core.info(`Set ${state} status (${context}) on ${owner}/${repo}@${sha}`);
