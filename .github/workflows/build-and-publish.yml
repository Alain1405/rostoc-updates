name: Build Rostoc Core

on:
  workflow_call:
    inputs:
      ref:
        description: "Branch, tag, or SHA to build from private repo"
        required: false
        type: string
        default: "main"
      commit_sha:
        description: "Commit SHA of the private repo (for stamping)"
        required: false
        type: string
      initiator:
        description: "Who triggered the run (for logging/summaries)"
        required: false
        type: string
      is_release:
        description: "Whether to execute release publishing steps"
        required: true
        type: boolean
  workflow_dispatch:
    inputs:
      ref:
        description: "Branch, tag, or SHA to build from private repo"
        required: false
        default: "main"
      commit_sha:
        description: "Commit SHA of the private repo (for stamping)"
        required: false
      initiator:
        description: "Who triggered the run (for logging/summaries)"
        required: false
      is_release:
        description: "Whether to execute release publishing steps"
        required: true
        type: boolean
        default: false

permissions:
  contents: write # Push updates to this repo / checkout private repo
  pages: write # Deploy Pages when releasing
  id-token: write # OIDC for Pages when releasing

env:
  PRIVATE_REPO: alain1405/rostoc
  UPDATES_DIR: updates
  VERSION_FILE: version.txt
  PYTAURI_GEN_TS: 0
  LC_ALL: en_US.UTF-8
  LANG: en_US.UTF-8
  LC_CTYPE: en_US.UTF-8

jobs:
  set-status:
    runs-on: ubuntu-latest
    env:
      TARGET_SHA: ${{ inputs.commit_sha || github.sha }}
      STATUS_CONTEXT: ${{ inputs.is_release && 'rostoc-updates/release' || 'rostoc-updates/ci' }}
      STATUS_DESCRIPTION: ${{ inputs.is_release && 'Public release build running' || 'Public CI build running' }}
    steps:
      - name: Detect status token
        id: detect-status-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Status updates skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; omitting private repo commit status.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Set pending status in private repo
        if: ${{ env.TARGET_SHA != '' && steps.detect-status-token.outputs.available == 'true' }}
        uses: actions/github-script@v7
        env:
          TARGET_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          github-token: ${{ secrets.UPDATES_REPO_TOKEN }}
          result-encoding: string
          script: |
            const [owner, repo] = process.env.PRIVATE_REPO.split('/');
            const sha = process.env.TARGET_SHA;
            const context = process.env.STATUS_CONTEXT;
            const description = process.env.STATUS_DESCRIPTION;
            const targetUrl = process.env.TARGET_URL;

            if (!owner || !repo) {
              core.warning(`Unable to parse PRIVATE_REPO env "${process.env.PRIVATE_REPO}"; skipping status update.`);
              return 'skipped';
            }

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state: 'pending',
              context,
              description,
              target_url: targetUrl
            });

            core.info(`Set pending status (${context}) on ${owner}/${repo}@${sha}`);
            return 'pending-set';

  build-macos:
    needs: set-status
    runs-on: macos-14
    env:
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
      SENTRY_SEND_DEFAULT_PII: ${{ secrets.SENTRY_SEND_DEFAULT_PII }}
      SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
      VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
      VITE_SENTRY_SEND_DEFAULT_PII: ${{ secrets.VITE_SENTRY_SEND_DEFAULT_PII }}
      VITE_SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
    timeout-minutes: 50
    outputs:
      version: ${{ steps.extract_version.outputs.version }}
      tarball: ${{ steps.prepare_artifacts.outputs.tarball }}
      signature: ${{ steps.prepare_artifacts.outputs.signature }}
    steps:
      # --- Checkout this updates repo ---
      - name: Checkout updates repo
        if: inputs.is_release
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: updates-repo

      # --- SSH method to read the private repo ---
      - name: Setup SSH agent for private repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}

      - name: Add GitHub to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout private repo (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src
          fetch-depth: 0
          sparse-checkout: |
            /*
            !/references/
          sparse-checkout-cone-mode: false

      - name: Capture release version
        if: inputs.is_release
        shell: bash
        run: |
          set -euo pipefail
          REF="${{ inputs.ref }}"
          VERSION=${REF#v}
          if [[ -z "$VERSION" ]]; then
            echo "::error::Unable to derive release version from ref '$REF'" >&2
            exit 1
          fi
          echo "RELEASE_VERSION=$VERSION" >> "$GITHUB_ENV"

      # --- Setup toolchains ---
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable Corepack (pnpm)
        run: corepack enable

      - name: Derive pnpm store path
        id: pnpm-store
        shell: bash
        run: |
          set -euo pipefail
          cd private-src
          echo "[INFO] pnpm version: $(pnpm --version || true)" >&2
          STORE_PATH=$(pnpm store path 2>/dev/null | tr -d '\r' || true)
          if [ -z "${STORE_PATH}" ]; then
            echo "[WARN] pnpm store path empty; falling back to default ~/.pnpm-store" >&2
            STORE_PATH="$HOME/.pnpm-store"
          fi
          mkdir -p "$STORE_PATH" || true
          echo "Using STORE_PATH=$STORE_PATH" >&2
          echo "STORE_PATH=$STORE_PATH" >> "$GITHUB_OUTPUT"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ hashFiles('private-src/pnpm-lock.yaml') }}
          restore-keys: pnpm-${{ runner.os }}-

      - name: Install uv (Python package manager)
        working-directory: private-src
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "UV_BIN=$HOME/.local/bin" >> $GITHUB_ENV
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache Python wheels
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/Library/Caches/pip
            ~/.cache/uv
            ~/Library/Caches/uv
          key: python-wheel-${{ runner.os }}-${{ hashFiles('private-src/uv.lock') }}
          restore-keys: |
            python-wheel-${{ runner.os }}-

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install sccache
        run: |
          curl -L https://github.com/mozilla/sccache/releases/download/v0.7.7/sccache-v0.7.7-aarch64-apple-darwin.tar.gz -o sccache.tgz
          tar -xzf sccache.tgz --strip-components=1
          sudo mv sccache /usr/local/bin/sccache
          export SCCACHE_DIR="$HOME/.cache/sccache"
          mkdir -p "$SCCACHE_DIR"
          echo "SCCACHE_DIR=$SCCACHE_DIR" >> $GITHUB_ENV

      - name: Enable sccache globally
        shell: bash
        run: |
          set -euo pipefail
          {
            echo RUSTC_WRAPPER=sccache
            echo SCCACHE_CACHE_SIZE=5G
            echo SCCACHE_LOG=debug
            echo RUST_LOG=sccache=debug
          } >> "$GITHUB_ENV"

      - name: Cache Rust (registry + git + sccache)
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ${{ env.SCCACHE_DIR }}
          key: rust-${{ runner.os }}-${{ hashFiles('private-src/**/Cargo.lock') }}
          restore-keys: rust-${{ runner.os }}-

      # --- Build Rostoc ---
      - name: Download embedded Python
        working-directory: private-src
        run: bash scripts/macos/download-py.sh

      - name: Install JS dependencies
        working-directory: private-src
        run: pnpm install --frozen-lockfile

      - name: Stamp build version
        working-directory: private-src
        env:
          GITHUB_SHA: ${{ inputs.commit_sha || github.sha }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          set -euo pipefail
          if [[ -n "${RELEASE_VERSION:-}" ]]; then
            scripts/ci/stamp_dev_version.sh --version "$RELEASE_VERSION"
          else
            scripts/ci/stamp_dev_version.sh
          fi

      - name: Extract version
        id: extract_version
        working-directory: private-src
        run: |
          set -euo pipefail
          VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "[INFO] Building version: $VERSION"
          echo "SENTRY_RELEASE=rostoc@$VERSION" >> "$GITHUB_ENV"
          echo "VITE_SENTRY_RELEASE=rostoc@$VERSION" >> "$GITHUB_ENV"
          echo "APP_VERSION=$VERSION" >> "$GITHUB_ENV"

      - name: Apply preview build tuning (no-release)
        if: ${{ !inputs.is_release }}
        working-directory: private-src
        shell: bash
        run: scripts/ci/apply_preview_rust_env.sh

      - name: Build application (with signing)
        working-directory: private-src
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          RUSTC_WRAPPER: sccache
          SCCACHE_DIR: ${{ env.SCCACHE_DIR }}
          SCCACHE_CACHE_SIZE: 5G
          ALLOW_PARTIAL_BUNDLE: 1
          ENABLE_RUNTIME_CACHE: "1"
          UV_DISABLE_WORKSPACE: "1"
          UV_PROJECT_ENVIRONMENT: "shared"
        run: |
          set -euo pipefail
          echo "[INFO] Starting build - output will be saved to build-macos.log"
          python scripts/build.py --locked 2>&1 | tee build-macos.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          sccache --show-stats || true
          exit $BUILD_EXIT_CODE

      - name: Save sccache statistics (macOS)
        working-directory: private-src
        run: |
          set -euo pipefail
          echo "=== sccache Statistics ===" > sccache-stats-macos.txt
          sccache --show-stats >> sccache-stats-macos.txt 2>&1 || echo "Failed to get sccache stats" >> sccache-stats-macos.txt

          # Calculate cache hit rate if possible
          if sccache --show-stats 2>/dev/null | grep -q "Cache hits"; then
            CACHE_HITS=$(sccache --show-stats 2>/dev/null | grep "Cache hits" | head -1 | awk '{print $3}' || echo "0")
            CACHE_MISSES=$(sccache --show-stats 2>/dev/null | grep "Cache misses" | head -1 | awk '{print $3}' || echo "0") 
            TOTAL=$((CACHE_HITS + CACHE_MISSES))
            if [ "$TOTAL" -gt 0 ]; then
              HIT_RATE=$((CACHE_HITS * 100 / TOTAL))
              echo "" >> sccache-stats-macos.txt
              echo "=== Analysis ===" >> sccache-stats-macos.txt
              echo "Cache hit rate: ${HIT_RATE}% (${CACHE_HITS}/${TOTAL})" >> sccache-stats-macos.txt
              SAVED_TIME=$((CACHE_HITS * 15)) # Assume ~15s saved per cache hit
              echo "Estimated time saved: ~${SAVED_TIME} seconds" >> sccache-stats-macos.txt
            fi
          fi

          echo "Generated sccache statistics report"
          cat sccache-stats-macos.txt

      - name: Verify app bundle
        working-directory: private-src
        run: bash scripts/verify_app_bundle.sh

      - name: Locate macOS app bundle
        id: locate_macos_bundle
        working-directory: private-src
        run: |
          set -euo pipefail
          SEARCH_DIRS=(target/bundle-release/bundle/macos src-tauri/target/bundle-release/bundle/macos src-tauri/target/release/bundle/macos target/release/bundle/macos)
          APP_PATH=""
          for dir in "${SEARCH_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              cand=$(find "$dir" -maxdepth 1 -type d -name '*.app' -print -quit 2>/dev/null || true)
              if [ -n "$cand" ]; then
                APP_PATH="$cand"
                break
              fi
            fi
          done
          if [ -z "$APP_PATH" ]; then
            echo "::error::No .app bundle located in expected directories"
            for dir in "${SEARCH_DIRS[@]}"; do
              if [ -d "$dir" ]; then
                echo "[INFO] Contents of $dir:"
                ls -al "$dir"
              else
                echo "[INFO] Missing search dir: $dir"
              fi
            done
            exit 1
          fi
          # Use canonical path only - no fallbacks
          PYBIN="$APP_PATH/Contents/Resources/pyembed/python/bin/python3"
          APP_PARENT=$(dirname "$APP_PATH")
          APP_NAME=$(basename "$APP_PATH")
          echo "app_path=$APP_PATH" >> "$GITHUB_OUTPUT"
          echo "bundle_dir=$APP_PARENT" >> "$GITHUB_OUTPUT"
          echo "app_name=$APP_NAME" >> "$GITHUB_OUTPUT"
          echo "python_path=$PYBIN" >> "$GITHUB_OUTPUT"
          if [ ! -x "$PYBIN" ]; then
            echo "::error::Embedded python binary not found at canonical location: $PYBIN"
            exit 1
          fi

      - name: Runtime smoke test (mac)
        if: steps.locate_macos_bundle.outputs.app_path != ''
        working-directory: private-src
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
          PYBIN_HINT: ${{ steps.locate_macos_bundle.outputs.python_path }}
        run: |
          set -euo pipefail
          if [ -z "${APP_BUNDLE}" ]; then
            echo '::error::app_path output missing from locate step'
            exit 1
          fi
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "::error::Resolved app bundle directory not found: $ABS_APP"
            ls -al "$GITHUB_WORKSPACE/private-src"
            exit 1
          fi
          PYBIN="${PYBIN_HINT}"
          if [[ -n "$PYBIN" && "$PYBIN" != /* ]]; then
            PYBIN="$GITHUB_WORKSPACE/private-src/$PYBIN"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            echo '::error::Embedded python3 not found at canonical location'
            exit 1
          fi
          echo "[INFO] Running runtime smoke test: $PYBIN"
          "$PYBIN" scripts/ci/unified_smoke_validator.py runtime \
            --platform mac \
            --comprehensive \
            --require-manifest \
            --debug-json macos_runtime_smoke_debug.json

      - name: GUI smoke test (non-fatal)
        if: always()
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          ABS_APP="${{ steps.locate_macos_bundle.outputs.app_path }}"
          if [ -z "$ABS_APP" ]; then
            echo "[WARN] No app bundle found, skipping GUI smoke test"
            exit 0
          fi
          PYBIN_HINT="${{ steps.embed_runtime.outputs.embedded_python_bin }}"
          PYBIN="${PYBIN_HINT}"
          if [[ -n "$PYBIN" && "$PYBIN" != /* ]]; then
            PYBIN="$GITHUB_WORKSPACE/private-src/$PYBIN"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            # Use canonical path - no fallbacks
            PYBIN="$ABS_APP/Contents/Resources/pyembed/python/bin/python3"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            echo "[WARN] Embedded python3 not found at canonical location, skipping GUI smoke test"
            exit 0
          fi
          echo "[INFO] Running GUI smoke test with 10s timeout"
          "$PYBIN" scripts/ci/unified_smoke_validator.py gui \
            --platform mac \
            --timeout 10 \
            --exe-path "$ABS_APP" \
            --debug-json macos_gui_smoke_debug.json \
            --strict

      - name: Upload macOS smoke diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macos-smoke-debug
          path: |
            private-src/macos_runtime_smoke_debug.json
            private-src/macos_gui_smoke_debug.json
          if-no-files-found: warn

      - name: Upload macOS build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macos-build-logs
          path: |
            private-src/build-macos.log
          if-no-files-found: warn

      - name: Archive macOS preview artifacts
        if: steps.locate_macos_bundle.outputs.app_path != ''
        id: archive_macos_preview
        working-directory: private-src
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
          BUNDLE_DIR: ${{ steps.locate_macos_bundle.outputs.bundle_dir }}
          APP_NAME: ${{ steps.locate_macos_bundle.outputs.app_name }}
        run: |
          set -euo pipefail
          if [ -z "${APP_BUNDLE}" ] || [ -z "${BUNDLE_DIR}" ] || [ -z "${APP_NAME}" ]; then
            echo "::error::Missing bundle metadata from locate_macos_bundle step"
            exit 1
          fi
          if [[ "${BUNDLE_DIR}" == /* ]]; then
            ABS_BUNDLE_DIR="${BUNDLE_DIR}"
          else
            ABS_BUNDLE_DIR="$GITHUB_WORKSPACE/private-src/${BUNDLE_DIR}"
          fi
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_BUNDLE_DIR" ]; then
            echo "::error::Bundle directory not found: $ABS_BUNDLE_DIR"
            exit 1
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "::error::App bundle not found: $ABS_APP"
            ls -al "$ABS_BUNDLE_DIR"
            exit 1
          fi
          if [ "${APP_NAME}" != "$(basename "$ABS_APP")" ]; then
            echo "::warning::App name output (${APP_NAME}) did not match bundle basename ($(basename "$ABS_APP"))"
          fi
          codesign --force --deep -s - "$ABS_APP" || echo "Ad-hoc codesign failed (continuing)"
          tar -czf coro-macos-build-preview.tar.gz -C "$ABS_BUNDLE_DIR" "$APP_NAME"
          ditto -c -k --sequesterRsrc --keepParent "$ABS_APP" coro-macos-build-preview.zip || echo "ditto zip failed"

      - name: Upload macOS preview artifacts
        if: steps.archive_macos_preview.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: macos-preview
          path: |
            private-src/coro-macos-build-preview.tar.gz
            private-src/coro-macos-build-preview.zip
          if-no-files-found: ignore

      - name: Upload sccache statistics (macOS)
        uses: actions/upload-artifact@v4
        with:
          name: sccache-stats-macos
          path: private-src/sccache-stats-macos.txt
          if-no-files-found: warn

      - name: Detect release upload token
        if: inputs.is_release
        id: detect-release-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Release asset upload skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; skipping release artifact upload.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Locate updater artifacts
        id: locate
        working-directory: private-src
        run: |
          set -euo pipefail
          # Prefer bundle-release profile artifacts, but search all known bundle directories.
          SEARCH_DIRS=(
            target/bundle-release/bundle/macos
            src-tauri/target/bundle-release/bundle/macos
            target/release/bundle/macos
            src-tauri/target/release/bundle/macos
          )

          TARBALL=""
          for dir in "${SEARCH_DIRS[@]}"; do
            [[ -d "$dir" ]] || continue
            cand=$(find "$dir" -maxdepth 1 -name 'Rostoc.app.tar.gz' -print -quit 2>/dev/null || true)
            if [[ -z "$cand" ]]; then
              cand=$(find "$dir" -maxdepth 1 -name 'Coro.app.tar.gz' -print -quit 2>/dev/null || true)
            fi
            if [[ -z "$cand" ]]; then
              cand=$(find "$dir" -maxdepth 1 -name '*.app.tar.gz' -print -quit 2>/dev/null || true)
            fi
            if [[ -n "$cand" ]]; then
              TARBALL="$cand"
              break
            fi
          done

          SIG_FILE=""
          if [[ -n "$TARBALL" ]]; then
            SIG_FILE="${TARBALL}.sig"
            if [[ ! -f "$SIG_FILE" ]]; then
              # Some bundler versions emit the signature alongside the tarball but do not use the simple .sig suffix.
              ALT_SIG=$(find "$(dirname "$TARBALL")" -maxdepth 1 -name "$(basename "$TARBALL").sig" -print -quit 2>/dev/null || true)
              if [[ -n "$ALT_SIG" ]]; then
                SIG_FILE="$ALT_SIG"
              fi
            fi
          fi

          echo "Tarball: $TARBALL" >&2
          echo "Signature: $SIG_FILE" >&2

          if [[ -z "$TARBALL" ]]; then
            echo 'Missing updater tarball (.app.tar.gz)'
            for dir in "${SEARCH_DIRS[@]}"; do
              if [[ -d "$dir" ]]; then
                echo "[INFO] Contents of $dir:" >&2
                ls -al "$dir" >&2
              else
                echo "[INFO] Missing search dir: $dir" >&2
              fi
            done
            exit 1
          fi
          if [[ -z "$SIG_FILE" || ! -f "$SIG_FILE" ]]; then
            echo 'Missing updater signature (.app.tar.gz.sig)'
            exit 1
          fi

          echo "tarball=$TARBALL" >> "$GITHUB_OUTPUT"
          echo "signature=$SIG_FILE" >> "$GITHUB_OUTPUT"

      - name: Prepare update bundle
        id: prepare_artifacts
        working-directory: private-src
        run: |
          set -euo pipefail
          TARBALL="${{ steps.locate.outputs.tarball }}"
          SIGNATURE="${{ steps.locate.outputs.signature }}"
          VERSION="${{ steps.extract_version.outputs.version }}"

          # Create updates directory
          mkdir -p "../${{ env.UPDATES_DIR }}/macos"

          # Copy artifacts with version-tagged names
          TARBALL_NAME="Rostoc-${VERSION}-darwin-aarch64.app.tar.gz"
          cp "$TARBALL" "../${{ env.UPDATES_DIR }}/macos/$TARBALL_NAME"
          cp "$SIGNATURE" "../${{ env.UPDATES_DIR }}/macos/${TARBALL_NAME}.sig"

          # Also copy as latest for convenience
          cp "$TARBALL" "../${{ env.UPDATES_DIR }}/macos/Rostoc.app.tar.gz"
          cp "$SIGNATURE" "../${{ env.UPDATES_DIR }}/macos/Rostoc.app.tar.gz.sig"

          # Stamp version file
          date -u +"%Y-%m-%dT%H:%M:%SZ" > "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"
          echo "version=${VERSION}" >> "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"
          echo "git_sha=$(git rev-parse --short HEAD)" >> "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"

          # Generate checksums
          (cd "../${{ env.UPDATES_DIR }}/macos" && shasum -a 256 *.tar.gz > checksums.txt)

          echo "tarball_name=$TARBALL_NAME" >> $GITHUB_OUTPUT

      - name: Upload release assets to private repo
        if: inputs.is_release && steps.detect-release-token.outputs.available == 'true'
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.UPDATES_REPO_TOKEN }}
          owner: alain1405
          repo: rostoc
          tag: ${{ inputs.ref }}
          draft: true
          allowUpdates: true
          artifacts: |
            updates/macos/Rostoc.app.tar.gz
            updates/macos/Rostoc.app.tar.gz.sig
            updates/version.txt
          artifactContentType: application/octet-stream

      - name: Generate latest.json
        if: inputs.is_release
        working-directory: updates-repo
        env:
          VERSION: ${{ steps.extract_version.outputs.version }}
          TARBALL_NAME: ${{ steps.prepare_artifacts.outputs.tarball_name }}
        run: |
          set -euo pipefail

          # Read signature
          SIG=$(cat "../${{ env.UPDATES_DIR }}/macos/${TARBALL_NAME}.sig")
          DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          NOTES="Release ${VERSION}"
          URL="https://alain1405.github.io/rostoc-updates/macos/${TARBALL_NAME}"

          # Generate latest.json
          jq -n \
            --arg v "$VERSION" \
            --arg sig "$SIG" \
            --arg date "$DATE" \
            --arg notes "$NOTES" \
            --arg url "$URL" \
            '{
              version: $v,
              notes: $notes,
              pub_date: $date,
              platforms: {
                "darwin-aarch64": {
                  url: $url,
                  signature: $sig
                }
              }
            }' > "../${{ env.UPDATES_DIR }}/latest.json"

          echo 'Generated latest.json:'
          cat "../${{ env.UPDATES_DIR }}/latest.json"

      - name: Upload artifacts for Pages deployment
        if: inputs.is_release
        uses: actions/upload-artifact@v4
        with:
          name: rostoc-updates
          path: ${{ env.UPDATES_DIR }}/*

  build-windows:
    needs: set-status
    runs-on: windows-2022
    env:
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
      SENTRY_SEND_DEFAULT_PII: ${{ secrets.SENTRY_SEND_DEFAULT_PII }}
      SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
      VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
      VITE_SENTRY_SEND_DEFAULT_PII: ${{ secrets.VITE_SENTRY_SEND_DEFAULT_PII }}
      VITE_SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
    timeout-minutes: 45
    outputs:
      version: ${{ steps.extract_version_win.outputs.version }}
      installer_name: ${{ inputs.is_release && steps.prepare_windows_updates.outputs.versioned_name || '' }}
      installer_latest: ${{ inputs.is_release && steps.prepare_windows_updates.outputs.latest_name || '' }}
      installer_checksum: ${{ inputs.is_release && steps.prepare_windows_updates.outputs.checksum || '' }}
    steps:
      - name: Setup SSH agent for private repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}

      - name: Add GitHub to known_hosts
        shell: bash
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout private repo (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src
          fetch-depth: 0

      - name: Capture release version
        if: inputs.is_release
        shell: bash
        run: |
          set -euo pipefail
          REF="${{ inputs.ref }}"
          VERSION=${REF#v}
          if [[ -z "$VERSION" ]]; then
            echo "::error::Unable to derive release version from ref '$REF'" >&2
            exit 1
          fi
          echo "RELEASE_VERSION=$VERSION" >> "$GITHUB_ENV"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable Corepack (pnpm)
        run: corepack enable

      - name: Derive pnpm store path
        id: windows-pnpm-store
        shell: bash
        run: |
          set -euo pipefail
          cd private-src
          echo "[INFO] pnpm version: $(pnpm --version || true)" >&2
          STORE_PATH=$(pnpm store path 2>/dev/null | tr -d '\r' || true)
          if [ -z "${STORE_PATH}" ]; then
            echo "[WARN] pnpm store path empty; falling back to default ~/.pnpm-store" >&2
            STORE_PATH="$HOME/.pnpm-store"
          fi
          mkdir -p "$STORE_PATH" || true
          echo "Using STORE_PATH=$STORE_PATH" >&2
          echo "STORE_PATH=$STORE_PATH" >> "$GITHUB_OUTPUT"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.windows-pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ hashFiles('private-src/pnpm-lock.yaml') }}
          restore-keys: pnpm-${{ runner.os }}-

      - name: Cache Python wheels
        uses: actions/cache@v4
        with:
          path: |
            ~\AppData\Local\pip\Cache
            ~\.cache\pip
            ~\AppData\Local\uv
          key: python-wheel-${{ runner.os }}-${{ hashFiles('private-src/uv.lock') }}
          restore-keys: |
            python-wheel-${{ runner.os }}-

      - name: Cache embedded Python
        uses: actions/cache@v4
        with:
          path: private-src/src-tauri/pyembed
          key: pyembed-${{ runner.os }}-${{ hashFiles('private-src/scripts/windows/download-py.ps1') }}
          restore-keys: |
            pyembed-${{ runner.os }}-

      - name: Cache WiX Tools
        uses: actions/cache@v4
        with:
          path: ~\AppData\Local\tauri\WixTools
          key: wix-tools-${{ runner.os }}-v314
          restore-keys: |
            wix-tools-${{ runner.os }}-

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install uv (Python helper)
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $script = Invoke-RestMethod -Uri 'https://astral.sh/uv/install.ps1'
          Invoke-Expression $script
          "$env:USERPROFILE\.local\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          Add-Content -Path $env:GITHUB_ENV -Value "UV_BIN=$($env:USERPROFILE)\.local\bin"

      - name: Install sccache
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $version = 'v0.7.7'
          $zipPath = Join-Path $env:RUNNER_TEMP 'sccache.zip'
          $extractDir = Join-Path $env:RUNNER_TEMP 'sccache'
          Invoke-WebRequest -Uri "https://github.com/mozilla/sccache/releases/download/$version/sccache-$version-x86_64-pc-windows-msvc.zip" -OutFile $zipPath
          if (Test-Path $extractDir) { Remove-Item $extractDir -Recurse -Force }
          Expand-Archive -Path $zipPath -DestinationPath $extractDir
          $exe = Get-ChildItem -Path $extractDir -Recurse -Filter sccache.exe | Select-Object -First 1
          if (-not $exe) { Write-Error 'sccache.exe not found in archive'; exit 1 }
          $binDir = Join-Path $env:USERPROFILE 'bin'
          if (-not (Test-Path $binDir)) { New-Item -ItemType Directory -Path $binDir | Out-Null }
          Copy-Item $exe.FullName (Join-Path $binDir 'sccache.exe') -Force
          "$binDir" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          Add-Content -Path $env:GITHUB_ENV -Value "SCCACHE_DIR=$($env:LOCALAPPDATA)\Mozilla\sccache"

      - name: Enable sccache globally
        shell: bash
        run: |
          set -euo pipefail
          echo RUSTC_WRAPPER=sccache >> "$GITHUB_ENV"
          echo SCCACHE_CACHE_SIZE=5G >> "$GITHUB_ENV"
          echo SCCACHE_LOG=debug >> "$GITHUB_ENV"
          echo RUST_LOG=sccache=debug >> "$GITHUB_ENV"

      - name: Cache Rust toolchain and sccache
        uses: actions/cache@v4
        with:
          path: |
            ~\.cargo\registry
            ~\.cargo\git
            ${{ env.SCCACHE_DIR }}
          key: rust-${{ runner.os }}-${{ hashFiles('private-src/**/Cargo.lock') }}
          restore-keys: |
            rust-${{ runner.os }}-

      - name: Configure Cargo environment
        shell: bash
        run: |
          {
            echo CARGO_INCREMENTAL=0
            echo CARGO_TERM_COLOR=always
          } >> "$GITHUB_ENV"

      - name: Download embedded Python
        working-directory: private-src
        shell: pwsh
        run: scripts/windows/download-py.ps1

      - name: Install JS dependencies
        working-directory: private-src
        run: pnpm install --frozen-lockfile

      - name: Pre-fetch Cargo dependencies (locked)
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          if [ -f Cargo.lock ]; then
            cargo fetch --locked
          elif [ -f src-tauri/Cargo.lock ]; then
            cargo fetch --locked --manifest-path src-tauri/Cargo.toml
          else
            echo "::warning::No Cargo.lock found before stamping; lockfile stability not guaranteed"
          fi

      - name: Stamp build version
        working-directory: private-src
        shell: bash
        env:
          GITHUB_SHA: ${{ inputs.commit_sha || github.sha }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
          # Avoid hitting the network and accidentally relocking during stamping
          CARGO_NET_OFFLINE: true
        run: |
          set -euo pipefail
          if [[ -n "${RELEASE_VERSION:-}" ]]; then
            scripts/ci/stamp_dev_version.sh --version "$RELEASE_VERSION"
          else
            scripts/ci/stamp_dev_version.sh
          fi

      - name: Refresh Cargo.lock offline after stamping
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          # The stamping step updates the workspace member version in Cargo.toml,
          # which can require touching Cargo.lock even if deps didn't change.
          # Refresh the lockfile OFFLINE to avoid any dependency churn.
          if [ -f Cargo.lock ]; then
            manifest="Cargo.toml"
          elif [ -f src-tauri/Cargo.lock ]; then
            manifest="src-tauri/Cargo.toml"
          else
            echo "::notice::No Cargo.lock found to refresh; skipping"
            exit 0
          fi
          echo "[INFO] Regenerating lockfile offline for manifest: $manifest"
          cargo generate-lockfile --offline --manifest-path "$manifest"

      - name: Apply preview build tuning (no-release)
        if: ${{ !inputs.is_release }}
        working-directory: private-src
        shell: bash
        run: scripts/ci/apply_preview_rust_env.sh

      - name: Normalize workspace path for caching (Windows)
        if: ${{ always() }}
        shell: pwsh
        working-directory: private-src
        run: |
          $ErrorActionPreference = 'Stop'
          $winPath = (Get-Location).Path
          $drive = 'S:'
          try {
            # Remove existing mapping if any
            if ((subst) -match "^$drive\\s+") { cmd /c "subst $drive /D" | Out-Null }
          } catch {}
          cmd /c "subst $drive $winPath" | Out-Null
          Add-Content -Path $env:GITHUB_ENV -Value "WORKSPACE_DRIVE=$drive"

      - name: Verify Cargo lockfile usage (Windows)
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          # Ensure Cargo.lock is honored; this prevents dependency churn and enables sccache reuse
          if [ -f Cargo.lock ]; then
            echo "[INFO] Verifying workspace lockfile with cargo fetch --locked"
            cargo fetch --locked
          elif [ -f src-tauri/Cargo.lock ]; then
            echo "[INFO] Verifying src-tauri lockfile with cargo fetch --locked --manifest-path src-tauri/Cargo.toml"
            cargo fetch --locked --manifest-path src-tauri/Cargo.toml
          else
            echo "::warning::No Cargo.lock found; builds may relock dependencies and hurt sccache effectiveness"
          fi

      - name: Extract version
        id: extract_version_win
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $content = Get-Content src-tauri/tauri.conf.json -Raw | ConvertFrom-Json
          if (-not $content.version) {
            throw 'Version not found in src-tauri/tauri.conf.json'
          }
          "version=$($content.version)" >> $env:GITHUB_OUTPUT
          Add-Content -Path $env:GITHUB_ENV -Value "SENTRY_RELEASE=rostoc@$($content.version)"
          Add-Content -Path $env:GITHUB_ENV -Value "VITE_SENTRY_RELEASE=rostoc@$($content.version)"
          Add-Content -Path $env:GITHUB_ENV -Value "APP_VERSION=$($content.version)"

      - name: Build application (unified)
        working-directory: private-src
        shell: bash
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          ALLOW_PARTIAL_BUNDLE: 1
          RUSTC_WRAPPER: sccache
          SCCACHE_DIR: ${{ env.SCCACHE_DIR }}
          SCCACHE_CACHE_SIZE: 10G
          ENABLE_RUNTIME_CACHE: "1"
          UV_DISABLE_WORKSPACE: "1"
          UV_PROJECT_ENVIRONMENT: "shared"
        run: |
          set -euo pipefail
          # Only purge PyO3 build artifacts for release builds; for preview keep them to improve cache reuse
          if [ "${{ inputs.is_release }}" = "true" ]; then
            find target -maxdepth 7 -name pyo3-build-config.txt -print -delete 2>/dev/null || true
            rm -rf target/release/build/pyo3* target/debug/build/pyo3* 2>/dev/null || true
          fi
          # Pre-build sccache stats for visibility
          sccache --show-stats || true

          # Use consolidated build script (replaces assemble_runtime.py + pnpm tauri build + embed_windows_runtime.py)
          echo "[INFO] Starting build - output will be saved to build-windows.log"

          # Retry logic to handle transient WiX download failures
          MAX_ATTEMPTS=3
          ATTEMPT=1
          BUILD_EXIT_CODE=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "[INFO] Build attempt $ATTEMPT of $MAX_ATTEMPTS"
            if python scripts/build.py --locked 2>&1 | tee build-windows.log; then
              BUILD_EXIT_CODE=0
              break
            else
              BUILD_EXIT_CODE=${PIPESTATUS[0]}
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "[WARN] Build failed with exit code $BUILD_EXIT_CODE, retrying in 10 seconds..."
                sleep 10
              else
                echo "[ERROR] Build failed after $MAX_ATTEMPTS attempts"
              fi
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done

          sccache --show-stats || true
          exit $BUILD_EXIT_CODE

      - name: Save sccache statistics (Windows)
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          echo "=== sccache Statistics ===" > sccache-stats-windows.txt
          sccache --show-stats >> sccache-stats-windows.txt 2>&1 || echo "Failed to get sccache stats" >> sccache-stats-windows.txt

          # Calculate cache hit rate if possible
          if sccache --show-stats 2>/dev/null | grep -q "Cache hits"; then
            CACHE_HITS=$(sccache --show-stats 2>/dev/null | grep "Cache hits" | head -1 | awk '{print $3}' || echo "0")
            CACHE_MISSES=$(sccache --show-stats 2>/dev/null | grep "Cache misses" | head -1 | awk '{print $3}' || echo "0")
            NON_CACHEABLE=$(sccache --show-stats 2>/dev/null | grep "Non-cacheable calls" | head -1 | awk '{print $3}' || echo "0")
            TOTAL=$((CACHE_HITS + CACHE_MISSES))
            if [ "$TOTAL" -gt 0 ]; then
              HIT_RATE=$((CACHE_HITS * 100 / TOTAL))
              echo "" >> sccache-stats-windows.txt
              echo "=== Analysis ===" >> sccache-stats-windows.txt
              echo "Cache hit rate: ${HIT_RATE}% (${CACHE_HITS}/${TOTAL})" >> sccache-stats-windows.txt
              echo "Non-cacheable calls: ${NON_CACHEABLE}" >> sccache-stats-windows.txt
              SAVED_TIME=$((CACHE_HITS * 20)) # Assume ~20s saved per cache hit on Windows
              echo "Estimated time saved: ~${SAVED_TIME} seconds" >> sccache-stats-windows.txt
              
              # Add interpretation of non-cacheable calls
              if [ "$NON_CACHEABLE" -gt 100 ]; then
                echo "" >> sccache-stats-windows.txt
                echo "=== Non-Cacheable Analysis ===" >> sccache-stats-windows.txt
                echo "High non-cacheable count detected. Common causes:" >> sccache-stats-windows.txt
                echo "- Build scripts (build.rs) invoking rustc directly" >> sccache-stats-windows.txt
                echo "- Proc macros with non-deterministic output" >> sccache-stats-windows.txt
                echo "- System-specific or timestamp-based code generation" >> sccache-stats-windows.txt
                echo "Enable SCCACHE_LOG=debug for detailed per-file analysis" >> sccache-stats-windows.txt
              fi
            fi
          fi

          echo "Generated sccache statistics report"
          cat sccache-stats-windows.txt

      - name: Check Python DLL linkage
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          # Support both tauri-bundled layout (target/...) and preview cargo build layout (src-tauri/target/...)
          EXE=$( (find target -type f -iname 'rostoc.exe' 2>/dev/null; find src-tauri/target -type f -iname 'rostoc.exe' 2>/dev/null) | head -n1 || true)
          if [ -z "$EXE" ]; then
            echo 'Rostoc.exe not found; available executables:' >&2
            find target -maxdepth 5 -type f -print || true
            find src-tauri/target -maxdepth 5 -type f -print || true
            exit 1
          fi
          echo "[INFO] Scanning for python DLL references in $EXE" >&2
          strings "$EXE" | grep -iE 'python3[0-9]+\.dll' | sort -u || echo '[WARN] No python3*.dll tokens found'
          if command -v objdump >/dev/null 2>&1; then
            objdump -p "$EXE" | grep -i 'DLL Name' | head -n 40 || true
          fi

      - name: Runtime smoke test
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          # Use canonical path only - no fallbacks (Windows: pyembed/python, not resources/pyembed/python)
          PYBIN=$(find target -type f -path '*pyembed/python/python.exe' -print -quit || true)
          if [ -z "$PYBIN" ]; then
            echo '::error::Embedded python.exe not found at canonical location: pyembed/python/python.exe'
            exit 1
          fi
          echo "[INFO] Running runtime smoke test: $PYBIN" >&2
          "$PYBIN" scripts/ci/unified_smoke_validator.py runtime \
            --platform windows \
            --comprehensive \
            --require-manifest \
            --debug-json windows_runtime_smoke_debug.json \
            --strict

      - name: GUI smoke test
        if: always()
        working-directory: private-src
        shell: bash
        run: |
          set -euo pipefail
          PYBIN=$(find target -type f -path '*pyembed/python/python.exe' -print -quit || true)
          if [ -z "$PYBIN" ]; then
            echo "[WARN] Embedded python.exe not found, skipping GUI smoke test" >&2
            exit 0
          fi
          # Find the exe that's in the same directory as pyembed (Windows: exe_parent/pyembed/python)
          PYEMBED_DIR=$(dirname "$PYBIN" | sed 's|/pyembed/python||')
          EXE="${PYEMBED_DIR}/rostoc.exe"
          if [ ! -f "$EXE" ]; then
            echo "[WARN] rostoc.exe not found at $EXE (same dir as pyembed), skipping GUI smoke test" >&2
            exit 0
          fi
          echo "[INFO] Running GUI smoke test with 10s timeout" >&2
          echo "[INFO] EXE: $EXE" >&2
          echo "[INFO] PYBIN: $PYBIN" >&2
          "$PYBIN" scripts/ci/unified_smoke_validator.py gui \
            --platform windows \
            --timeout 10 \
            --exe-path "$EXE" \
            --debug-json windows_gui_smoke_debug.json \
            --strict

      - name: Upload smoke diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-smoke-debug
          path: |
            private-src/windows_runtime_smoke_debug.json
            private-src/windows_gui_smoke_debug.json
          if-no-files-found: warn

      - name: Upload Windows build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-build-logs
          path: |
            private-src/build-windows.log
          if-no-files-found: warn

      - name: Archive Windows artifacts
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          # Support both tauri-bundled layout (target/...) and preview cargo build layout (src-tauri/target/...)
          $exe = Get-ChildItem -Path @('target','src-tauri/target') -Recurse -File -Filter 'rostoc.exe' -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $exe) { Write-Error 'No Rostoc.exe found for archiving'; exit 1 }
          $bindir = Split-Path -Parent $exe.FullName
          Write-Host "[INFO] Found exe at $($exe.FullName) (bindir=$bindir)"
          $stage = "windows_bundle_stage"
          if (Test-Path $stage) { Remove-Item $stage -Recurse -Force }
          New-Item -ItemType Directory -Path $stage | Out-Null
          Copy-Item $exe.FullName (Join-Path $stage $exe.Name)
          if (Test-Path (Join-Path $bindir 'resources')) {
            Copy-Item (Join-Path $bindir 'resources') (Join-Path $stage 'resources') -Recurse
          }
          $dllPatterns = @('python3*.dll','vcruntime140.dll','vcruntime140_1.dll')
          foreach ($pat in $dllPatterns) {
            $matches = Get-ChildItem -Path $bindir -Filter $pat -ErrorAction SilentlyContinue
            foreach ($m in $matches) {
              Copy-Item $m.FullName (Join-Path $stage $m.Name) -Force
              Write-Host "[INFO] Included DLL $($m.Name)"
            }
          }
          if (Test-Path build/runtime_staging/runtime_manifest.json) {
            Copy-Item build/runtime_staging/runtime_manifest.json windows_runtime_manifest.json -ErrorAction SilentlyContinue
          }
          $zipPath = 'coro-windows-bundle.zip'
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path (Join-Path $stage '*') -DestinationPath $zipPath -Force
          Write-Host "[INFO] Created $zipPath"

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-preview
          path: |
            private-src/coro-windows-bundle.zip
            private-src/windows_runtime_manifest.json
          if-no-files-found: error

      - name: Upload sccache statistics (Windows)
        uses: actions/upload-artifact@v4
        with:
          name: sccache-stats-windows
          path: private-src/sccache-stats-windows.txt
          if-no-files-found: warn

      - name: Locate Windows updater artifacts
        if: inputs.is_release
        id: locate_windows_updater
        working-directory: private-src
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $patterns = @('*.msi', '*.msi.zip', '*setup*.exe', '*.exe', '*.zip')
          $selected = $null
          foreach ($pattern in $patterns) {
            $found = Get-ChildItem -Path target -Recurse -File -Filter $pattern -ErrorAction SilentlyContinue | Where-Object {
              $_.FullName -match 'bundle'
            } | Sort-Object LastWriteTime -Descending | Select-Object -First 1
            if ($found) {
              $selected = $found
              break
            }
          }
          if (-not $selected) {
            throw 'No Windows installer artifact found under target/'
          }
          $sigPath = "$($selected.FullName).sig"
          if (-not (Test-Path $sigPath)) {
            $sigCandidate = Get-ChildItem -Path $selected.DirectoryName -Filter "$($selected.BaseName)*.sig" -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($sigCandidate) {
              $sigPath = $sigCandidate.FullName
            } else {
              throw "Signature file not found for $($selected.Name)"
            }
          }
          "artifact=$($selected.FullName)" >> $env:GITHUB_OUTPUT
          "artifact_name=$($selected.Name)" >> $env:GITHUB_OUTPUT
          "signature=$sigPath" >> $env:GITHUB_OUTPUT

      - name: Prepare Windows update bundle
        if: inputs.is_release
        id: prepare_windows_updates
        working-directory: private-src
        shell: pwsh
        env:
          UPDATES_DIR: ${{ env.UPDATES_DIR }}
        run: |
          $ErrorActionPreference = 'Stop'
          $version = '${{ steps.extract_version_win.outputs.version }}'
          if ([string]::IsNullOrWhiteSpace($version)) {
            throw 'Version output missing from extract_version_win step'
          }
          $artifactPath = '${{ steps.locate_windows_updater.outputs.artifact }}'
          $signaturePath = '${{ steps.locate_windows_updater.outputs.signature }}'
          if ([string]::IsNullOrWhiteSpace($artifactPath) -or -not (Test-Path -LiteralPath $artifactPath)) {
            throw "Installer artifact '$artifactPath' missing"
          }
          if ([string]::IsNullOrWhiteSpace($signaturePath) -or -not (Test-Path -LiteralPath $signaturePath)) {
            throw "Signature file '$signaturePath' missing"
          }
          $artifact = Get-Item -LiteralPath $artifactPath
          $signature = Get-Item -LiteralPath $signaturePath
          $platform = 'windows-x86_64'
          $parent = Split-Path -Parent $PWD
          $updatesRoot = Join-Path $parent $env:UPDATES_DIR
          if (-not (Test-Path -LiteralPath $updatesRoot)) {
            New-Item -ItemType Directory -Path $updatesRoot | Out-Null
          }
          $windowsDir = Join-Path $updatesRoot 'windows'
          if (-not (Test-Path -LiteralPath $windowsDir)) {
            New-Item -ItemType Directory -Path $windowsDir | Out-Null
          }
          $extension = $artifact.Extension
          if ($artifact.Name -like '*.msi.zip' -or $artifact.Name -like '*.exe.zip') {
            $extension = '.zip'
          }
          if (-not $extension) {
            $extension = [System.IO.Path]::GetExtension($artifact.Name)
          }
          $versionedName = "Rostoc-$version-$platform$extension"
          $versionedPath = Join-Path $windowsDir $versionedName
          Copy-Item -LiteralPath $artifact.FullName -Destination $versionedPath -Force
          $sigTarget = "$versionedPath.sig"
          Copy-Item -LiteralPath $signature.FullName -Destination $sigTarget -Force
          $latestName = "Rostoc-$platform$extension"
          $latestPath = Join-Path $windowsDir $latestName
          Copy-Item -LiteralPath $artifact.FullName -Destination $latestPath -Force
          Copy-Item -LiteralPath $signature.FullName -Destination "$latestPath.sig" -Force
          $hash = Get-FileHash -Path $versionedPath -Algorithm SHA256
          $checksumPath = Join-Path $windowsDir 'checksums.txt'
          "$($hash.Hash)  $versionedName" | Out-File -FilePath $checksumPath -Encoding utf8
          "versioned_name=$versionedName" >> $env:GITHUB_OUTPUT
          "latest_name=$latestName" >> $env:GITHUB_OUTPUT
          "checksum=$($hash.Hash)" >> $env:GITHUB_OUTPUT

      - name: Upload artifacts for Pages deployment (Windows)
        if: inputs.is_release
        uses: actions/upload-artifact@v4
        with:
          name: rostoc-updates-windows
          path: updates/windows

  publish-to-pages:
    needs:
      - build-macos
      - build-windows
    if: inputs.is_release
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Checkout updates repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: rostoc-updates
          path: updates

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: rostoc-updates-windows
          path: updates/windows

      - name: Merge Windows entry into latest.json
        run: |
          set -euo pipefail

          VERSION=""
          if [[ -f updates/version.txt ]]; then
            VERSION=$(grep -E '^version=' updates/version.txt | head -n 1 | cut -d'=' -f2- || true)
          fi
          if [[ -z "$VERSION" ]]; then
            VERSION='${{ needs.build-windows.outputs.version }}'
          fi
          if [[ ! -f updates/latest.json ]]; then
            echo "::error::updates/latest.json not found prior to merge" >&2
            exit 1
          fi
          shopt -s nullglob
          files=(updates/windows/Rostoc-${VERSION}-windows-x86_64.*)
          win_file=""
          for f in "${files[@]}"; do
            if [[ "$f" != *.sig ]]; then
              win_file="$f"
              break
            fi
          done
          if [[ -z "$win_file" ]]; then
            echo "::error::No Windows installer artifact found for version $VERSION under updates/windows" >&2
            ls -al updates/windows || true
            exit 1
          fi
          sig_file="${win_file}.sig"
          if [[ ! -f "$sig_file" ]]; then
            echo "::error::Missing signature for Windows artifact: $sig_file" >&2
            exit 1
          fi
          signature=$(cat "$sig_file")
          url="https://alain1405.github.io/rostoc-updates/windows/$(basename "$win_file")"
          tmp=updates/latest.json.tmp
          jq --arg url "$url" --arg sig "$signature" '.platforms["windows-x86_64"] = { url: $url, signature: $sig }' updates/latest.json > "$tmp"
          mv "$tmp" updates/latest.json

      # - name: Commit & push updates (optional - for history)
      #   run: |
      #     git config user.name "github-actions[bot]"
      #     git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      #     git add updates || true
      #     if ! git diff --cached --quiet; then
      #       git commit -m "chore: publish updates v${{ needs.build-macos.outputs.version }} ($(date -u +%F))"
      #       git push
      #     else
      #       echo "No changes to commit"
      #     fi

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: updates

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Summary
        run: |
          echo "## 🚀 Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          VERSION=""
          if [[ -f updates/version.txt ]]; then
            VERSION=$(grep -E '^version=' updates/version.txt | head -n 1 | cut -d'=' -f2- || true)
          fi
          if [[ -z "$VERSION" ]]; then
            VERSION='${{ needs.build-macos.outputs.version }}'
          fi
          echo "**Version:** ${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Updates URL:** https://alain1405.github.io/rostoc-updates/latest.json" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts:**" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ needs.build-macos.outputs.tarball }}" ]; then
            echo "- macOS artifact: macos/${{ needs.build-macos.outputs.tarball }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- macOS artifact: macos/Rostoc.app.tar.gz" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "${{ needs.build-windows.outputs.installer_name }}" ]; then
            echo "- Windows artifact: windows/${{ needs.build-windows.outputs.installer_name }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "**Pages URL:** ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY

  finalize-status:
    runs-on: ubuntu-latest
    needs:
      - build-macos
      - build-windows
    if: ${{ always() }}
    env:
      TARGET_SHA: ${{ inputs.commit_sha || github.sha }}
      STATUS_CONTEXT: ${{ inputs.is_release && 'rostoc-updates/release' || 'rostoc-updates/ci' }}
    steps:
      - name: Detect status token
        id: detect-finalize-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo '### ℹ️ Final status skipped' >> "$GITHUB_STEP_SUMMARY"
            echo '\`UPDATES_REPO_TOKEN\` not provided; final commit status omitted.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: Update commit status with result
        if: ${{ env.TARGET_SHA != '' && steps.detect-finalize-token.outputs.available == 'true' }}
        uses: actions/github-script@v7
        env:
          TARGET_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          MAC_RESULT: ${{ needs.build-macos.result }}
          WIN_RESULT: ${{ needs.build-windows.result }}
        with:
          github-token: ${{ secrets.UPDATES_REPO_TOKEN }}
          script: |
            const [owner, repo] = process.env.PRIVATE_REPO.split('/');
            const sha = process.env.TARGET_SHA;
            const context = process.env.STATUS_CONTEXT;
            const targetUrl = process.env.TARGET_URL;
            const results = [process.env.MAC_RESULT, process.env.WIN_RESULT];
            const allSucceeded = results.every((r) => r === 'success' || r === 'skipped');

            const state = allSucceeded ? 'success' : 'failure';
            const description = allSucceeded
              ? (context.endsWith('release') ? 'Public release build succeeded' : 'Public CI build succeeded')
              : 'Public build failed — see logs in rostoc-updates repo';

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state,
              context,
              description,
              target_url: targetUrl
            });

            core.info(`Set ${state} status (${context}) on ${owner}/${repo}@${sha}`);
