name: Build Desktop (Reusable)

on:
  workflow_call:
    inputs:
      ref:
        required: true
        type: string
        description: 'Git reference to build (branch, tag, or commit SHA)'
      commit_sha:
        required: false
        type: string
        description: 'Commit SHA for status updates (defaults to github.sha)'
      is_release:
        required: false
        type: boolean
        default: false
        description: 'Whether this is a release build'

env:
  PRIVATE_REPO: alain1405/rostoc
  UPDATES_DIR: updates
  VERSION_FILE: version.txt

jobs:
  build-desktop:
    strategy:
      fail-fast: false
      matrix:
        include:
          # ========== EXISTING (BLOCKING) PLATFORMS ==========
          # macOS ARM64 (M1) — required for release
          - os: macos-15
            platform: macos
            arch: aarch64
            name: 'macOS ARM64 (M1)'
            is_optional: false

          # Windows x64 — required for release
          - os: windows-2022
            platform: windows
            arch: x86_64
            name: 'Windows x64'
            is_optional: false

          # ========== NEW (OPTIONAL) PLATFORMS ==========
          # macOS Intel (x86-64) — experimental, does not block releases
          - os: macos-15-intel
            platform: macos
            arch: x86_64
            name: 'macOS Intel x86-64'
            is_optional: true

          # Windows x86 (32-bit) — experimental via cross-compile, does not block releases
          - os: windows-2022
            platform: windows
            arch: i686
            name: 'Windows x86 (32-bit)'
            is_optional: true

          # Linux AppImage — experimental, does not block releases
          - os: ubuntu-latest
            platform: linux
            arch: x86_64
            name: 'Linux AppImage x86-64'
            is_optional: true

    runs-on: ${{ matrix.os }}
    # Optional jobs continue even if they fail; blocking jobs abort the matrix
    continue-on-error: ${{ matrix.is_optional }}

    env:
      SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
      SENTRY_SEND_DEFAULT_PII: ${{ secrets.SENTRY_SEND_DEFAULT_PII }}
      SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
      VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
      VITE_SENTRY_SEND_DEFAULT_PII: ${{ secrets.VITE_SENTRY_SEND_DEFAULT_PII }}
      VITE_SENTRY_ENVIRONMENT: ${{ inputs.is_release && 'production' || 'ci' }}
    timeout-minutes: ${{ matrix.platform == 'linux' && 30 || 50 }}
    outputs:
      version: ${{ steps.extract_version.outputs.version }}
      platform: ${{ matrix.platform }}
      arch: ${{ matrix.arch }}

    steps:
      # --- Platform detection and initialization ---
      - name: Initialize platform-specific config
        id: platform_config
        run: |
          set -euo pipefail
          case "${{ matrix.platform }}" in
            macos)
              {
                echo "build_command=python scripts/build.py --locked"
                echo "artifact_extension=tar.gz"
                echo "test_smoke=true"
                if [ "${{ matrix.arch }}" == "x86_64" ]; then
                  echo "target=x86_64-apple-darwin"
                  echo "py_url_fragment=macos-x64"
                else
                  echo "target=aarch64-apple-darwin"
                  echo "py_url_fragment=macos-arm64"
                fi
              } >> "$GITHUB_OUTPUT"
              ;;
            windows)
              {
                echo "build_command=python scripts/build.py --locked --bundles msi"
                echo "artifact_extension=msi"
                echo "test_smoke=true"
                if [ "${{ matrix.arch }}" == "x86_64" ]; then
                  echo "target=x86_64-pc-windows-msvc"
                  echo "py_url_fragment=windows-x64"
                else
                  echo "target=i686-pc-windows-msvc"
                  echo "py_url_fragment=windows-x86"
                  echo "cross_compile_args=--target i686-pc-windows-msvc"
                fi
              } >> "$GITHUB_OUTPUT"
              ;;
            linux)
              {
                echo "build_command=python scripts/build.py --locked --bundles appimage"
                echo "artifact_extension=AppImage"
                echo "test_smoke=true"
                echo "target=x86_64-unknown-linux-gnu"
                echo "py_url_fragment=linux-x64"
              } >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "::error::Unknown platform: ${{ matrix.platform }}"
              exit 1
              ;;
          esac
        shell: bash

      - name: '[macOS Intel] Confirm runner architecture'
        if: matrix.arch == 'x86_64' && matrix.platform == 'macos'
        run: |
          RUNNER_ARCH=$(uname -m)
          if [ "$RUNNER_ARCH" != "x86_64" ]; then
            echo "::warning::Runner reports architecture $RUNNER_ARCH but matrix specifies x86_64"
          fi
          echo "[INFO] macOS runner architecture: $RUNNER_ARCH"
          uname -a

      - name: '[Windows x86] Verify cross-compile capability'
        if: matrix.arch == 'i686' && matrix.platform == 'windows'
        run: |
          echo "[INFO] Windows x86 (32-bit) build via MSVC cross-compile on x64 runner"
          rustup target add i686-pc-windows-msvc
          echo "✅ i686-pc-windows-msvc target installed"
        shell: bash

      - name: '[Linux] Install system dependencies for AppImage'
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y libssl-dev libffi-dev libglib2.0-0 libx11-6 fuse3
          echo "✅ AppImage build dependencies installed"
        shell: bash

      # --- Checkout this updates repo ---
      - name: Checkout updates repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # --- SSH method to read the private repo ---
      - name: Setup SSH agent for private repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}

      - name: Add GitHub to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout private repo (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PRIVATE_REPO }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.PRIVATE_REPO_SSH_KEY }}
          path: private-src
          fetch-depth: 0
          sparse-checkout: |
            /*
            !/references/
          sparse-checkout-cone-mode: false

      - name: Restore production icons
        working-directory: private-src
        run: |
          set -euo pipefail
          if [ -x scripts/restore_prod_icons.sh ]; then
            bash scripts/restore_prod_icons.sh
          else
            echo "::warning::restore_prod_icons.sh missing; skipping icon restore"
          fi

      - name: Capture release version
        if: inputs.is_release
        shell: bash
        run: |
          set -euo pipefail
          REF="${{ inputs.ref }}"
          VERSION=${REF#v}
          if [[ -z "$VERSION" ]]; then
            echo "::error::Unable to derive release version from ref '$REF'" >&2
            exit 1
          fi
          echo "RELEASE_VERSION=$VERSION" >> "$GITHUB_ENV"

      # --- Setup toolchains ---
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Enable Corepack (pnpm)
        run: corepack enable

      - name: Derive pnpm store path
        id: pnpm-store
        shell: bash
        run: |
          set -euo pipefail
          cd private-src
          echo "[INFO] pnpm version: $(pnpm --version || true)" >&2
          STORE_PATH=$(pnpm store path 2>/dev/null | tr -d '\r' || true)
          if [ -z "${STORE_PATH}" ]; then
            echo "[WARN] pnpm store path empty; falling back to default ~/.pnpm-store" >&2
            STORE_PATH="$HOME/.pnpm-store"
          fi
          mkdir -p "$STORE_PATH" || true
          echo "Using STORE_PATH=$STORE_PATH" >&2
          echo "STORE_PATH=$STORE_PATH" >> "$GITHUB_OUTPUT"

      - name: Compute dependency hashes
        id: dependency-hashes
        shell: bash
        run: |
          scripts/ci/hash_lockfiles.sh private-src

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ steps.dependency-hashes.outputs.pnpm }}
          restore-keys: pnpm-${{ runner.os }}-

      - name: Install uv (Python package manager)
        working-directory: private-src
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "UV_BIN=$HOME/.local/bin" >> "$GITHUB_ENV"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Cache Python wheels
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/Library/Caches/pip
            ~/.cache/uv
            ~/Library/Caches/uv
          key: python-wheel-${{ runner.os }}-${{ steps.dependency-hashes.outputs.uv }}
          restore-keys: |
            python-wheel-${{ runner.os }}-

      - name: '[macOS] Install Apple signing certificate'
        if: matrix.platform == 'macos'
        working-directory: private-src
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail
          scripts/macos/install_signing_certificate.sh

      - name: '[macOS] Debug signing keychain state'
        if: matrix.platform == 'macos' && always()
        working-directory: private-src
        shell: bash
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail
          echo "[DEBUG] Listing configured keychains" >&2
          security list-keychains || true
          echo "[DEBUG] Available signing identities" >&2
          security find-identity -v -p codesigning || true
          if [ -n "${APPLE_SIGNING_IDENTITY:-}" ]; then
            echo "[DEBUG] Matching certificate summary for ${APPLE_SIGNING_IDENTITY}" >&2
            security find-certificate -Z -a -c "$APPLE_SIGNING_IDENTITY" 2>/dev/null | grep -E 'SHA-1|SHA-256|"' || true
          else
            echo "[DEBUG] APPLE_SIGNING_IDENTITY not provided" >&2
          fi

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies and build artifacts
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: private-src
          shared-key: macos
          save-if: ${{ github.ref == 'refs/heads/main' }}

      # --- Build Rostoc ---
      - name: Download embedded Python
        working-directory: private-src
        run: |
          set -euo pipefail
          case "${{ matrix.platform }}" in
            macos)
              bash scripts/macos/download-py.sh
              ;;
            windows)
              pwsh scripts/windows/download-py.ps1
              ;;
            linux)
              # Linux: Python will be downloaded by PyTauri's AppImage bundler
              echo "[INFO] Linux AppImage: Python runtime download handled by bundler"
              ;;
          esac

      - name: Install JS dependencies
        working-directory: private-src
        run: pnpm install --frozen-lockfile

      - name: Stamp build version
        working-directory: private-src
        env:
          GITHUB_SHA: ${{ inputs.commit_sha || github.sha }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          set -euo pipefail
          if [[ -n "${RELEASE_VERSION:-}" ]]; then
            scripts/ci/stamp_dev_version.sh --version "$RELEASE_VERSION"
          else
            scripts/ci/stamp_dev_version.sh
          fi

      - name: '[macOS] Stage Python runtime (before Tauri build/sign)'
        if: matrix.platform == 'macos'
        working-directory: private-src
        run: |
          set -euo pipefail
          echo "[INFO] Pre-staging Python runtime to ensure stable file attributes before signing"
          python3 scripts/bundle_runtime.py --target=release --stage-only
          echo "[INFO] Runtime staging complete - files are now stable for Tauri's signing"

      - name: '[macOS] Sign Python binaries in staging (before sync to src-tauri)'
        if: matrix.platform == 'macos'
        working-directory: private-src
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail
          echo "[INFO] Signing Python binaries and libraries in build/runtime_staging/pyembed/python"
          echo "[INFO] These will be synced to src-tauri/ by build.py, preserving signatures"

          # Sign all executables in bin/
          if [ -d "build/runtime_staging/pyembed/python/bin" ]; then
            find build/runtime_staging/pyembed/python/bin -type f \( -perm +111 -o -name "python*" \) | while read -r binary; do
              # Skip if it's a text file (script) not a binary
              if file "$binary" | grep -q "Mach-O"; then
                echo "  Signing: $(basename "$binary")"
                codesign --force --sign "$APPLE_SIGNING_IDENTITY" \
                  --timestamp \
                  --options runtime \
                  "$binary" || echo "    Warning: failed to sign $binary"
              fi
            done
          fi

          # Sign all dylibs and .so files in lib/
          if [ -d "build/runtime_staging/pyembed/python/lib" ]; then
            find build/runtime_staging/pyembed/python/lib -type f \( -name "*.dylib" -o -name "*.so" \) | while read -r lib; do
              echo "  Signing: $(basename "$lib")"
              codesign --force --sign "$APPLE_SIGNING_IDENTITY" \
                --timestamp \
                --options runtime \
                "$lib" || echo "    Warning: failed to sign $lib"
            done
          fi

          echo "[INFO] Python runtime signing complete in staging area"

      - name: Extract version
        id: extract_version
        working-directory: private-src
        run: |
          set -euo pipefail
          VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "[INFO] Building version: $VERSION"
          {
            echo "SENTRY_RELEASE=rostoc@$VERSION"
            echo "VITE_SENTRY_RELEASE=rostoc@$VERSION"
            echo "APP_VERSION=$VERSION"
          } >> "$GITHUB_ENV"

      - name: Validate version matches tag (release builds only)
        if: inputs.is_release
        working-directory: private-src
        run: |
          set -euo pipefail
          VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          REF="${{ inputs.ref }}"

          # Extract version from tag (e.g., v0.2.81 -> 0.2.81)
          if [[ "$REF" =~ ^v([0-9]+\.[0-9]+\.[0-9]+.*)$ ]]; then
            TAG_VERSION="${BASH_REMATCH[1]}"
            echo "[INFO] Tag version: $TAG_VERSION"
            echo "[INFO] Code version: $VERSION"

            if [[ "$TAG_VERSION" != "$VERSION" ]]; then
              echo "::error::Version mismatch! Tag is $REF (version $TAG_VERSION) but tauri.conf.json has version $VERSION"
              exit 1
            fi

            echo "✅ Version validation passed: $VERSION matches tag $REF"
          else
            echo "[WARN] Not building from a version tag (ref: $REF), skipping version validation"
          fi

      - name: Apply preview build tuning (no-release)
        if: ${{ !inputs.is_release }}
        working-directory: private-src
        shell: bash
        run: scripts/ci/apply_preview_rust_env.sh

      - name: Build application
        working-directory: private-src
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          ENABLE_RUNTIME_CACHE: '1'
          UV_DISABLE_WORKSPACE: '1'
          UV_PROJECT_ENVIRONMENT: 'shared'
          RUST_TARGET: ${{ steps.platform_config.outputs.target }}
          CROSS_COMPILE_ARGS: ${{ steps.platform_config.outputs.cross_compile_args || '' }}
        run: |
          set -euo pipefail
          BUILD_CMD="${{ steps.platform_config.outputs.build_command }}"
          LOG_FILE="build-${{ matrix.platform }}-${{ matrix.arch }}.log"
          echo "[INFO] Starting build (${{ matrix.name }}) - output will be saved to $LOG_FILE"
          # shellcheck disable=SC2086
          $BUILD_CMD 2>&1 | tee "$LOG_FILE"

      - name: '[macOS] Sign DMG'
        if: matrix.platform == 'macos'
        working-directory: private-src
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail

          # Find the DMG file
          DMG_PATH=$(find target/release/bundle/dmg -name "*.dmg" -type f | head -n 1)

          if [ -z "$DMG_PATH" ]; then
            echo "::error::No DMG file found in target/release/bundle/dmg"
            exit 1
          fi

          echo "[INFO] Found DMG: $DMG_PATH"
          echo "[INFO] Signing DMG with identity: $APPLE_SIGNING_IDENTITY"

          # Sign the DMG
          codesign --sign "$APPLE_SIGNING_IDENTITY" \
                   --force \
                   --verbose \
                   --timestamp \
                   --options runtime \
                   "$DMG_PATH"

          # Verify the signature
          echo "[INFO] Verifying DMG signature"
          codesign --verify --deep --strict --verbose=2 "$DMG_PATH"

          echo "[INFO] DMG signed successfully"

      - name: '[macOS] Verify app bundle'
        if: matrix.platform == 'macos'
        working-directory: private-src
        run: bash scripts/verify_app_bundle.sh

      - name: '[macOS] Locate macOS app bundle'
        if: matrix.platform == 'macos'
        id: locate_macos_bundle
        working-directory: private-src
        run: |
          set -euo pipefail
          SEARCH_DIRS=(target/bundle-release/bundle/macos src-tauri/target/bundle-release/bundle/macos src-tauri/target/release/bundle/macos target/release/bundle/macos)
          APP_PATH=""
          for dir in "${SEARCH_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              cand=$(find "$dir" -maxdepth 1 -type d -name '*.app' -print -quit 2>/dev/null || true)
              if [ -n "$cand" ]; then
                APP_PATH="$cand"
                break
              fi
            fi
          done
          if [ -z "$APP_PATH" ]; then
            echo "::error::No .app bundle located in expected directories"
            for dir in "${SEARCH_DIRS[@]}"; do
              if [ -d "$dir" ]; then
                echo "[INFO] Contents of $dir:"
                ls -al "$dir"
              else
                echo "[INFO] Missing search dir: $dir"
              fi
            done
            exit 1
          fi
          # Use canonical path from runtime_config
          PYTHON_PATH=$(python3 scripts/ci/get_runtime_path.py python_path unix)
          MACOS_RES=$(python3 scripts/ci/get_runtime_path.py macos_resources)
          PYBIN="$APP_PATH/$MACOS_RES/$PYTHON_PATH"
          APP_PARENT=$(dirname "$APP_PATH")
          APP_NAME=$(basename "$APP_PATH")
          {
            echo "app_path=$APP_PATH"
            echo "bundle_dir=$APP_PARENT"
            echo "app_name=$APP_NAME"
            echo "python_path=$PYBIN"
          } >> "$GITHUB_OUTPUT"
          if [ ! -x "$PYBIN" ]; then
            echo "::error::Embedded python binary not found at canonical location: $PYBIN"
            exit 1
          fi

      - name: '[macOS] Runtime smoke test'
        if: matrix.platform == 'macos' && steps.locate_macos_bundle.outputs.app_path != ''
        working-directory: private-src
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
          PYBIN_HINT: ${{ steps.locate_macos_bundle.outputs.python_path }}
        run: |
          set -euo pipefail
          if [ -z "${APP_BUNDLE}" ]; then
            echo '::error::app_path output missing from locate step'
            exit 1
          fi
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "::error::Resolved app bundle directory not found: $ABS_APP"
            ls -al "$GITHUB_WORKSPACE/private-src"
            exit 1
          fi
          PYBIN="${PYBIN_HINT}"
          if [[ -n "$PYBIN" && "$PYBIN" != /* ]]; then
            PYBIN="$GITHUB_WORKSPACE/private-src/$PYBIN"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            echo '::error::Embedded python3 not found at canonical location'
            exit 1
          fi
          echo "[INFO] Running runtime smoke test: $PYBIN"
          "$PYBIN" scripts/ci/unified_smoke_validator.py runtime \
            --platform mac \
            --comprehensive \
            --require-manifest \
            --debug-json macos_runtime_smoke_debug.json

      - name: '[macOS] Dump codesign diagnostics'
        if: matrix.platform == 'macos' && steps.locate_macos_bundle.outputs.app_path != ''
        working-directory: private-src
        shell: bash
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
        run: |
          set -euo pipefail
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "[DEBUG] App bundle not found for codesign diagnostics: $ABS_APP" >&2
            exit 0
          fi
          echo "[DEBUG] codesign -dv --verbose=4 output" >&2
          codesign -dv --verbose=4 "$ABS_APP" 2>&1 || true
          echo "[DEBUG] codesign --verify --deep --strict output" >&2
          codesign --verify --deep --strict "$ABS_APP" 2>&1 || true
          if command -v spctl >/dev/null 2>&1; then
            echo "[DEBUG] spctl assessment" >&2
            spctl --assess --type exec "$ABS_APP" 2>&1 || true
          fi

      - name: '[macOS] GUI smoke test (non-fatal)'
        if: matrix.platform == 'macos' && always()
        working-directory: private-src
        shell: bash
        env:
          PYBIN_HINT: ${{ steps.locate_macos_bundle.outputs.python_path }}
        run: |
          set -euo pipefail
          ABS_APP="${{ steps.locate_macos_bundle.outputs.app_path }}"
          if [ -z "$ABS_APP" ]; then
            echo "[WARN] No app bundle found, skipping GUI smoke test"
            exit 0
          fi
          PYBIN="${PYBIN_HINT}"
          if [[ -n "$PYBIN" && "$PYBIN" != /* ]]; then
            PYBIN="$GITHUB_WORKSPACE/private-src/$PYBIN"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            # Use canonical path from runtime_config
            PYTHON_PATH=$(python3 scripts/ci/get_runtime_path.py python_path unix)
            MACOS_RES=$(python3 scripts/ci/get_runtime_path.py macos_resources)
            PYBIN="$ABS_APP/$MACOS_RES/$PYTHON_PATH"
          fi
          if [ -z "$PYBIN" ] || [ ! -x "$PYBIN" ]; then
            echo "[WARN] Embedded python3 not found at canonical location, skipping GUI smoke test"
            exit 0
          fi
          echo "[INFO] Running GUI smoke test with 10s timeout"
          "$PYBIN" scripts/ci/unified_smoke_validator.py gui \
            --platform mac \
            --timeout 10 \
            --exe-path "$ABS_APP" \
            --debug-json macos_gui_smoke_debug.json \
            --strict

      - name: Upload macOS smoke diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macos-smoke-debug
          path: |
            private-src/macos_runtime_smoke_debug.json
            private-src/macos_gui_smoke_debug.json
          if-no-files-found: warn

      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            private-src/build-*.log
          if-no-files-found: warn

      - name: Upload smoke test diagnostics
        if: always() && matrix.platform == 'macos'
        uses: actions/upload-artifact@v4
        with:
          name: smoke-debug-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            private-src/macos_runtime_smoke_debug.json
            private-src/macos_gui_smoke_debug.json
          if-no-files-found: warn

      - name: '[macOS] Archive preview artifacts'
        if: matrix.platform == 'macos' && steps.locate_macos_bundle.outputs.app_path != ''
        id: archive_macos_preview
        working-directory: private-src
        env:
          APP_BUNDLE: ${{ steps.locate_macos_bundle.outputs.app_path }}
          BUNDLE_DIR: ${{ steps.locate_macos_bundle.outputs.bundle_dir }}
          APP_NAME: ${{ steps.locate_macos_bundle.outputs.app_name }}
          IS_RELEASE: ${{ inputs.is_release }}
        run: |
          set -euo pipefail
          if [ -z "${APP_BUNDLE}" ] || [ -z "${BUNDLE_DIR}" ] || [ -z "${APP_NAME}" ]; then
            echo "::error::Missing bundle metadata from locate_macos_bundle step"
            exit 1
          fi
          if [[ "${BUNDLE_DIR}" == /* ]]; then
            ABS_BUNDLE_DIR="${BUNDLE_DIR}"
          else
            ABS_BUNDLE_DIR="$GITHUB_WORKSPACE/private-src/${BUNDLE_DIR}"
          fi
          if [[ "${APP_BUNDLE}" == /* ]]; then
            ABS_APP="${APP_BUNDLE}"
          else
            ABS_APP="$GITHUB_WORKSPACE/private-src/${APP_BUNDLE}"
          fi
          if [ ! -d "$ABS_BUNDLE_DIR" ]; then
            echo "::error::Bundle directory not found: $ABS_BUNDLE_DIR"
            exit 1
          fi
          if [ ! -d "$ABS_APP" ]; then
            echo "::error::App bundle not found: $ABS_APP"
            ls -al "$ABS_BUNDLE_DIR"
            exit 1
          fi
          if [ "${APP_NAME}" != "$(basename "$ABS_APP")" ]; then
            echo "::warning::App name output (${APP_NAME}) did not match bundle basename ($(basename "$ABS_APP"))"
          fi
          if [ "${IS_RELEASE}" != "true" ]; then
            codesign --force --deep -s - "$ABS_APP" || echo "Ad-hoc codesign failed (continuing)"
          fi
          tar -czf rostoc-macos-build-preview.tar.gz -C "$ABS_BUNDLE_DIR" "$APP_NAME"
          ditto -c -k --sequesterRsrc --keepParent "$ABS_APP" rostoc-macos-build-preview.zip || echo "ditto zip failed"

      - name: '[macOS] Upload preview artifacts'
        if: matrix.platform == 'macos' && steps.archive_macos_preview.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: preview-macos-${{ matrix.arch }}
          path: |
            private-src/rostoc-macos-build-preview.tar.gz
            private-src/rostoc-macos-build-preview.zip
          if-no-files-found: ignore

      - name: Detect release upload token
        if: inputs.is_release
        id: detect-release-token
        run: |
          if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            # shellcheck disable=SC2016
            echo '### ℹ️ Release asset upload skipped' >> "$GITHUB_STEP_SUMMARY"
            # shellcheck disable=SC2016
            echo '\`UPDATES_REPO_TOKEN\` not provided; skipping release artifact upload.' >> "$GITHUB_STEP_SUMMARY"
          fi
        env:
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}

      - name: '[macOS] Locate updater artifacts'
        if: matrix.platform == 'macos'
        id: locate
        working-directory: private-src
        run: |
          set -euo pipefail
          # Prefer bundle-release profile artifacts, but search all known bundle directories.
          SEARCH_DIRS=(
            target/bundle-release/bundle/macos
            src-tauri/target/bundle-release/bundle/macos
            target/release/bundle/macos
            src-tauri/target/release/bundle/macos
          )

          TARBALL=""
          for dir in "${SEARCH_DIRS[@]}"; do
            [[ -d "$dir" ]] || continue
            cand=$(find "$dir" -maxdepth 1 -name 'Rostoc.app.tar.gz' -print -quit 2>/dev/null || true)
            if [[ -z "$cand" ]]; then
              cand=$(find "$dir" -maxdepth 1 -name 'Rostoc.app.tar.gz' -print -quit 2>/dev/null || true)
            fi
            if [[ -z "$cand" ]]; then
              cand=$(find "$dir" -maxdepth 1 -name '*.app.tar.gz' -print -quit 2>/dev/null || true)
            fi
            if [[ -n "$cand" ]]; then
              TARBALL="$cand"
              break
            fi
          done

          SIG_FILE=""
          if [[ -n "$TARBALL" ]]; then
            SIG_FILE="${TARBALL}.sig"
            if [[ ! -f "$SIG_FILE" ]]; then
              # Some bundler versions emit the signature alongside the tarball but do not use the simple .sig suffix.
              ALT_SIG=$(find "$(dirname "$TARBALL")" -maxdepth 1 -name "$(basename "$TARBALL").sig" -print -quit 2>/dev/null || true)
              if [[ -n "$ALT_SIG" ]]; then
                SIG_FILE="$ALT_SIG"
              fi
            fi
          fi

          echo "Tarball: $TARBALL" >&2
          echo "Signature: $SIG_FILE" >&2

          if [[ -z "$TARBALL" ]]; then
            echo 'Missing updater tarball (.app.tar.gz)'
            for dir in "${SEARCH_DIRS[@]}"; do
              if [[ -d "$dir" ]]; then
                echo "[INFO] Contents of $dir:" >&2
                ls -al "$dir" >&2
              else
                echo "[INFO] Missing search dir: $dir" >&2
              fi
            done
            exit 1
          fi
          if [[ -z "$SIG_FILE" || ! -f "$SIG_FILE" ]]; then
            echo 'Missing updater signature (.app.tar.gz.sig)'
            exit 1
          fi

          echo "tarball=$TARBALL" >> "$GITHUB_OUTPUT"
          echo "signature=$SIG_FILE" >> "$GITHUB_OUTPUT"

      - name: '[macOS] Prepare update bundle'
        if: matrix.platform == 'macos'
        id: prepare_artifacts
        working-directory: private-src
        run: |
          set -euo pipefail
          TARBALL="${{ steps.locate.outputs.tarball }}"
          SIGNATURE="${{ steps.locate.outputs.signature }}"
          VERSION="${{ steps.extract_version.outputs.version }}"

          # Create updates directory
          mkdir -p "../${{ env.UPDATES_DIR }}/macos"

          # Copy artifacts with version-tagged names
          TARBALL_NAME="Rostoc-${VERSION}-darwin-aarch64.app.tar.gz"
          cp "$TARBALL" "../${{ env.UPDATES_DIR }}/macos/$TARBALL_NAME"
          cp "$SIGNATURE" "../${{ env.UPDATES_DIR }}/macos/${TARBALL_NAME}.sig"

          # Also copy as latest for convenience
          cp "$TARBALL" "../${{ env.UPDATES_DIR }}/macos/Rostoc.app.tar.gz"
          cp "$SIGNATURE" "../${{ env.UPDATES_DIR }}/macos/Rostoc.app.tar.gz.sig"

          # Copy DMG if present (will be replaced after notarization)
          DMG_PATH=$(find target -maxdepth 5 -type f -name "*.dmg" -print -quit || true)
          if [[ -n "${DMG_PATH}" && -f "${DMG_PATH}" ]]; then
            DMG_NAME="Rostoc_${VERSION}_aarch64.dmg"
            echo "[INFO] Found DMG at ${DMG_PATH}, copying to updates as ${DMG_NAME}"
            cp "${DMG_PATH}" "../${{ env.UPDATES_DIR }}/macos/${DMG_NAME}"
          else
            echo "[WARN] No DMG found in target directory"
          fi

          # Stamp version file
          {
            date -u +"%Y-%m-%dT%H:%M:%SZ"
            echo "version=${VERSION}"
            echo "git_sha=$(git rev-parse --short HEAD)"
          } > "../${{ env.UPDATES_DIR }}/${{ env.VERSION_FILE }}"

          # Generate checksums
          (cd "../${{ env.UPDATES_DIR }}/macos" && shasum -a 256 ./*.tar.gz > checksums.txt)

          echo "tarball_name=$TARBALL_NAME" >> "$GITHUB_OUTPUT"

      - name: '[macOS] Upload binaries to DigitalOcean Spaces'
        if: matrix.platform == 'macos' && inputs.is_release && steps.detect-release-token.outputs.available == 'true'
        working-directory: private-src
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.DO_SPACES_SECRET_KEY }}
          AWS_DEFAULT_REGION: sgp1
          SPACES_BUCKET: ${{ secrets.DO_SPACES_BUCKET }}
          SPACES_ENDPOINT: ${{ secrets.DO_SPACES_ENDPOINT }}
        run: |
          set -euo pipefail
          VERSION="${{ steps.extract_version.outputs.version }}"

          # Install AWS CLI if not present
          if ! command -v aws &> /dev/null; then
            echo "Installing AWS CLI..."
            pip install --quiet awscli
          fi

          echo "[INFO] Uploading macOS binaries to Spaces: ${SPACES_BUCKET}/releases/v${VERSION}/"

          # Upload macOS artifacts
          aws s3 cp \
            --endpoint-url "${SPACES_ENDPOINT}" \
            "../${{ env.UPDATES_DIR }}/macos/Rostoc-${VERSION}-darwin-aarch64.app.tar.gz" \
            "s3://${SPACES_BUCKET}/releases/v${VERSION}/Rostoc-${VERSION}-darwin-aarch64.app.tar.gz" \
            --acl public-read

          aws s3 cp \
            --endpoint-url "${SPACES_ENDPOINT}" \
            "../${{ env.UPDATES_DIR }}/macos/Rostoc-${VERSION}-darwin-aarch64.app.tar.gz.sig" \
            "s3://${SPACES_BUCKET}/releases/v${VERSION}/Rostoc-${VERSION}-darwin-aarch64.app.tar.gz.sig" \
            --acl public-read

          # Upload DMG if present (will be replaced by stapler after notarization)
          if [ -f "../${{ env.UPDATES_DIR }}/macos/Rostoc_${VERSION}_aarch64.dmg" ]; then
            echo "[INFO] Uploading unsigned DMG (will be replaced after notarization)"
            aws s3 cp \
              --endpoint-url "${SPACES_ENDPOINT}" \
              "../${{ env.UPDATES_DIR }}/macos/Rostoc_${VERSION}_aarch64.dmg" \
              "s3://${SPACES_BUCKET}/releases/v${VERSION}/Rostoc_${VERSION}_aarch64.dmg" \
              --acl public-read
          fi

          echo "[INFO] ✅ Upload complete"

      - name: '[macOS] Upload artifacts for manifest generation'
        if: matrix.platform == 'macos' && inputs.is_release
        uses: actions/upload-artifact@v4
        with:
          name: rostoc-updates-${{ matrix.arch }}
          path: ${{ env.UPDATES_DIR }}/*
