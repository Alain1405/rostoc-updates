name: 'Build Artifacts (Locate, prepare, upload to Spaces)'
description: 'Stage artifacts for release, upload to DigitalOcean Spaces, prepare manifest'

inputs:
  platform:
    description: 'Platform being built (macos, windows, linux)'
    required: true
  arch:
    description: 'Architecture being built (aarch64, x86_64, i686)'
    required: true
  is_release:
    description: 'Whether this is a release build'
    required: false
    default: 'false'
  version:
    description: 'Version string to use in artifact naming'
    required: false
  updates_repo_token:
    description: 'Token for uploading release artifacts'
    required: false
  do_spaces_access_key:
    description: 'DigitalOcean Spaces access key'
    required: false
  do_spaces_secret_key:
    description: 'DigitalOcean Spaces secret key'
    required: false
  do_spaces_bucket:
    description: 'DigitalOcean Spaces bucket name'
    required: false
  do_spaces_endpoint:
    description: 'DigitalOcean Spaces endpoint'
    required: false
  variant:
    description: 'App variant (production|staging)'
    required: false
    default: 'production'

runs:
  using: 'composite'
  steps:
    - name: Detect release upload token
      if: ${{ inputs.is_release == 'true' }}
      id: detect-release-token
      shell: bash
      env:
        UPDATES_REPO_TOKEN: ${{ inputs.updates_repo_token }}
      run: |
        if [ -n "${UPDATES_REPO_TOKEN:-}" ]; then
          echo "available=true" >> "$GITHUB_OUTPUT"
        else
          echo "available=false" >> "$GITHUB_OUTPUT"
          echo '### ℹ️ Release asset upload skipped' >> "$GITHUB_STEP_SUMMARY"
          echo '`UPDATES_REPO_TOKEN` not provided; skipping release artifact upload.' >> "$GITHUB_STEP_SUMMARY"
        fi

    # ======== macOS ========
    - name: '[macOS] Locate updater artifacts'
      if: ${{ inputs.platform == 'macos' }}
      id: locate-macos
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        SEARCH_DIRS=()
        while IFS= read -r line; do
          SEARCH_DIRS+=("$line")
        done < <(python scripts/ci/get_bundle_dirs.py macos tarball)

        TARBALL=""
        for dir in "${SEARCH_DIRS[@]}"; do
          [[ -d "$dir" ]] || continue
          cand=$(find "$dir" -maxdepth 1 -name '*.app.tar.gz' -print -quit 2>/dev/null || true)
          if [[ -n "$cand" ]]; then
            TARBALL="$cand"
            break
          fi
        done

        SIG_FILE=""
        if [[ -n "$TARBALL" ]]; then
          SIG_FILE="${TARBALL}.sig"
          if [[ ! -f "$SIG_FILE" ]]; then
            ALT_SIG=$(find "$(dirname "$TARBALL")" -maxdepth 1 -name "$(basename "$TARBALL").sig" -print -quit 2>/dev/null || true)
            if [[ -n "$ALT_SIG" ]]; then
              SIG_FILE="$ALT_SIG"
            fi
          fi
        fi

        echo "Tarball: $TARBALL" >&2
        echo "Signature: $SIG_FILE" >&2

        if [[ -z "$TARBALL" ]]; then
          echo 'Missing updater tarball (.app.tar.gz)'
          for dir in "${SEARCH_DIRS[@]}"; do
            if [[ -d "$dir" ]]; then
              echo "[INFO] Contents of $dir:" >&2
              ls -al "$dir" >&2
            fi
          done
          exit 1
        fi
        if [[ -z "$SIG_FILE" || ! -f "$SIG_FILE" ]]; then
          echo 'Missing updater signature (.app.tar.gz.sig)'
          exit 1
        fi

        echo "tarball=$TARBALL" >> "$GITHUB_OUTPUT"
        echo "signature=$SIG_FILE" >> "$GITHUB_OUTPUT"

    - name: '[macOS] Prepare update bundle'
      if: ${{ inputs.platform == 'macos' }}
      id: prepare-macos
      working-directory: private-src
      shell: bash
      env:
        VERSION: ${{ inputs.version }}
        ARCH: ${{ inputs.arch }}
      run: |
        set -euo pipefail
        TARBALL="${{ steps.locate-macos.outputs.tarball }}"
        SIGNATURE="${{ steps.locate-macos.outputs.signature }}"

        # Create updates directory
        mkdir -p "../updates/macos"

        # Copy artifacts with version-tagged names
        TARBALL_NAME="Rostoc-${VERSION}-darwin-${ARCH}.app.tar.gz"
        cp "$TARBALL" "../updates/macos/$TARBALL_NAME"
        cp "$SIGNATURE" "../updates/macos/${TARBALL_NAME}.sig"

        # Also copy as latest for convenience
        cp "$TARBALL" "../updates/macos/Rostoc.app.tar.gz"
        cp "$SIGNATURE" "../updates/macos/Rostoc.app.tar.gz.sig"

        # Copy DMG if present (will be replaced after notarization)
        SEARCH_DIRS=()
        while IFS= read -r line; do
          SEARCH_DIRS+=("$line")
        done < <(python scripts/ci/get_bundle_dirs.py macos dmg)

        DMG_PATH=""
        for dir in "${SEARCH_DIRS[@]}"; do
          [[ -d "$dir" ]] || continue
          cand=$(find "$dir" -maxdepth 1 -name "*.dmg" -print -quit 2>/dev/null || true)
          if [[ -n "$cand" && -f "$cand" ]]; then
            DMG_PATH="$cand"
            break
          fi
        done

        if [[ -n "${DMG_PATH}" && -f "${DMG_PATH}" ]]; then
          DMG_NAME="Rostoc_${VERSION}_${ARCH}.dmg"
          DMG_SIZE=$(du -h "${DMG_PATH}" | cut -f1)
          echo "[INFO] Found DMG at ${DMG_PATH} (${DMG_SIZE}), copying to updates as ${DMG_NAME}"
          cp -v "${DMG_PATH}" "../updates/macos/${DMG_NAME}"
          ls -lh "../updates/macos/${DMG_NAME}"
        else
          echo "[WARN] No DMG found in any search directory"
          for dir in "${SEARCH_DIRS[@]}"; do
            if [[ -d "$dir" ]]; then
              echo "[DEBUG] Contents of $dir:" >&2
              ls -la "$dir" 2>/dev/null || true
            fi
          done
        fi

        # Stamp version file
        {
          date -u +"%Y-%m-%dT%H:%M:%SZ"
          echo "version=${VERSION}"
          echo "git_sha=$(git rev-parse --short HEAD)"
        } > "../updates/version.txt"

        # Generate checksums
        (cd "../updates/macos" && sha256sum ./*.tar.gz > checksums.txt || shasum -a 256 ./*.tar.gz > checksums.txt)

        echo "tarball_name=$TARBALL_NAME" >> "$GITHUB_OUTPUT"

    - name: '[macOS] Upload binaries to DigitalOcean Spaces'
      if: ${{ inputs.platform == 'macos' && inputs.is_release == 'true' && steps.detect-release-token.outputs.available == 'true' }}
      working-directory: private-src
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.do_spaces_access_key }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.do_spaces_secret_key }}
        AWS_DEFAULT_REGION: sgp1
        SPACES_BUCKET: ${{ inputs.do_spaces_bucket }}
        SPACES_ENDPOINT: ${{ inputs.do_spaces_endpoint }}
        VERSION: ${{ inputs.version }}
        ARCH: ${{ inputs.arch }}
        RELEASE_PREFIX: ${{ inputs.variant == 'staging' && 'releases/staging' || 'releases' }}
      run: |
        set -euo pipefail

        # Install AWS CLI if not present
        if ! command -v aws &> /dev/null; then
          echo "Installing AWS CLI..."
          pip install --quiet awscli
        fi

        RELEASE_PREFIX=${RELEASE_PREFIX:-releases}
        echo "[INFO] Uploading macOS binaries to Spaces: ${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/"

        # Upload macOS artifacts
        aws s3 cp \
          --endpoint-url "${SPACES_ENDPOINT}" \
          "../updates/macos/Rostoc-${VERSION}-darwin-${ARCH}.app.tar.gz" \
          "s3://${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/Rostoc-${VERSION}-darwin-${ARCH}.app.tar.gz" \
          --acl public-read

        aws s3 cp \
          --endpoint-url "${SPACES_ENDPOINT}" \
          "../updates/macos/Rostoc-${VERSION}-darwin-${ARCH}.app.tar.gz.sig" \
          "s3://${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/Rostoc-${VERSION}-darwin-${ARCH}.app.tar.gz.sig" \
          --acl public-read

        # Upload DMG if present
        if [ -f "../updates/macos/Rostoc_${VERSION}_${ARCH}.dmg" ]; then
          echo "[INFO] Uploading unsigned DMG (will be replaced after notarization)"
          aws s3 cp \
            --endpoint-url "${SPACES_ENDPOINT}" \
            "../updates/macos/Rostoc_${VERSION}_${ARCH}.dmg" \
            "s3://${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/Rostoc_${VERSION}_${ARCH}.dmg" \
            --acl public-read
        fi

        echo "[INFO] ✅ macOS upload complete"

    # ======== Windows ========
    - name: '[Windows] Locate updater artifacts'
      if: ${{ inputs.platform == 'windows' }}
      id: locate-windows
      working-directory: private-src
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        $searchRoots = @('target', 'src-tauri/target')
        $candidates = @()
        foreach ($root in $searchRoots) {
          if (-not (Test-Path -LiteralPath $root)) { continue }
          $found = Get-ChildItem -Path $root -Recurse -File -Filter '*.msi' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending
          if ($found) { $candidates += $found }
        }
        $msi = $candidates | Select-Object -First 1
        if (-not $msi) {
          throw 'MSI artifact not found under target/ or src-tauri/target/'
        }
        $sigPath = "$($msi.FullName).sig"
        if (-not (Test-Path $sigPath)) {
          $sigCandidate = Get-ChildItem -Path $msi.DirectoryName -Filter "$($msi.BaseName)*.sig" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($sigCandidate) {
            $sigPath = $sigCandidate.FullName
          } else {
            throw "Signature file not found for $($msi.Name)"
          }
        }
        "artifact=$($msi.FullName)" >> $env:GITHUB_OUTPUT
        "signature=$sigPath" >> $env:GITHUB_OUTPUT
        Write-Host "[INFO] Located MSI: $($msi.FullName)"
        Write-Host "[INFO] Located signature: $sigPath"

    - name: '[Windows] Prepare update bundle'
      if: ${{ inputs.platform == 'windows' && inputs.is_release == 'true' }}
      id: prepare-windows
      working-directory: private-src
      shell: pwsh
      env:
        VERSION: ${{ inputs.version }}
      run: |
        $ErrorActionPreference = 'Stop'
        $version = $env:VERSION
        $artifact = '${{ steps.locate-windows.outputs.artifact }}'
        $signature = '${{ steps.locate-windows.outputs.signature }}'
        $arch = '${{ inputs.arch }}'

        if ([string]::IsNullOrWhiteSpace($version)) { throw 'Version missing' }
        if (-not (Test-Path $artifact)) { throw "Artifact missing: $artifact" }
        if (-not (Test-Path $signature)) { throw "Signature missing: $signature" }

        # Create Windows updates directory
        $parent = Split-Path -Parent $PWD
        $updatesRoot = Join-Path $parent 'updates'
        $windowsDir = Join-Path $updatesRoot 'windows'
        New-Item -ItemType Directory -Path $windowsDir -Force | Out-Null

        # Determine architecture label for filename
        $archLabel = if ($arch -eq 'i686') { 'x86' } else { 'x64' }

        # Copy artifacts with version-tagged names
        $extension = [System.IO.Path]::GetExtension($artifact)
        $msiName = "Rostoc-${version}-windows-${archLabel}${extension}"
        Copy-Item $artifact (Join-Path $windowsDir $msiName) -Force
        Copy-Item $signature (Join-Path $windowsDir "${msiName}.sig") -Force

        # Also copy as latest for convenience
        $latestName = "Rostoc-windows-${archLabel}${extension}"
        Copy-Item $artifact (Join-Path $windowsDir $latestName) -Force
        Copy-Item $signature (Join-Path $windowsDir "${latestName}.sig") -Force

        # Generate checksums
        $hash = Get-FileHash -Path (Join-Path $windowsDir $msiName) -Algorithm SHA256
        "$($hash.Hash)  $msiName" | Out-File -FilePath (Join-Path $windowsDir 'checksums.txt') -Encoding utf8 -Append

        Write-Host "[INFO] Windows artifacts staged: $msiName"
        "msi_name=$msiName" >> $env:GITHUB_OUTPUT

    - name: '[Windows] Upload binaries to DigitalOcean Spaces'
      if: ${{ inputs.platform == 'windows' && inputs.is_release == 'true' && steps.detect-release-token.outputs.available == 'true' }}
      working-directory: private-src
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.do_spaces_access_key }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.do_spaces_secret_key }}
        AWS_DEFAULT_REGION: sgp1
        SPACES_BUCKET: ${{ inputs.do_spaces_bucket }}
        SPACES_ENDPOINT: ${{ inputs.do_spaces_endpoint }}
        VERSION: ${{ inputs.version }}
        ARCH: ${{ inputs.arch }}
        RELEASE_PREFIX: ${{ inputs.variant == 'staging' && 'releases/staging' || 'releases' }}
      run: |
        set -euo pipefail
        ARCH_LABEL=$([ "$ARCH" = "i686" ] && echo "x86" || echo "x64")

        # Install AWS CLI if not present
        if ! command -v aws &> /dev/null; then
          echo "Installing AWS CLI..."
          pip install --quiet awscli
        fi

        RELEASE_PREFIX=${RELEASE_PREFIX:-releases}
        echo "[INFO] Uploading Windows binaries to Spaces: ${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/"

        # Upload Windows artifacts
        aws s3 cp \
          --endpoint-url "${SPACES_ENDPOINT}" \
          "../updates/windows/Rostoc-${VERSION}-windows-${ARCH_LABEL}.msi" \
          "s3://${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/Rostoc-${VERSION}-windows-${ARCH_LABEL}.msi" \
          --acl public-read

        aws s3 cp \
          --endpoint-url "${SPACES_ENDPOINT}" \
          "../updates/windows/Rostoc-${VERSION}-windows-${ARCH_LABEL}.msi.sig" \
          "s3://${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/Rostoc-${VERSION}-windows-${ARCH_LABEL}.msi.sig" \
          --acl public-read

        echo "[INFO] ✅ Windows upload complete"

    # ======== Linux ========
    - name: '[Linux] Locate updater artifacts'
      if: ${{ inputs.platform == 'linux' }}
      id: locate-linux
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        SEARCH_DIRS=(target/release/bundle src-tauri/target/release/bundle)
        APPIMAGE=""
        for dir in "${SEARCH_DIRS[@]}"; do
          [[ -d "$dir" ]] || continue
          cand=$(find "$dir" -maxdepth 1 -name '*.AppImage' -print -quit 2>/dev/null || true)
          if [[ -n "$cand" ]]; then
            APPIMAGE="$cand"
            break
          fi
        done

        if [[ -z "$APPIMAGE" ]]; then
          echo "::error::No AppImage artifact found in target/ or src-tauri/target/"
          exit 1
        fi

        if [[ ! -f "$APPIMAGE" ]]; then
          echo "::error::AppImage file not found: $APPIMAGE"
          exit 1
        fi

        echo "appimage=$APPIMAGE" >> "$GITHUB_OUTPUT"
        echo "[INFO] Located AppImage: $APPIMAGE"

    - name: '[Linux] Prepare update bundle'
      if: ${{ inputs.platform == 'linux' && inputs.is_release == 'true' }}
      id: prepare-linux
      working-directory: private-src
      shell: bash
      env:
        VERSION: ${{ inputs.version }}
      run: |
        set -euo pipefail
        APPIMAGE="${{ steps.locate-linux.outputs.appimage }}"

        if [[ -z "$VERSION" ]]; then
          echo "::error::Version missing"
          exit 1
        fi
        if [[ ! -f "$APPIMAGE" ]]; then
          echo "::error::AppImage missing: $APPIMAGE"
          exit 1
        fi

        # Create Linux updates directory
        mkdir -p "../updates/linux"

        # Copy AppImage with version-tagged name
        APPIMAGE_NAME="Rostoc-${VERSION}-x86_64.AppImage"
        cp "$APPIMAGE" "../updates/linux/$APPIMAGE_NAME"

        # Also copy as latest for convenience
        cp "$APPIMAGE" "../updates/linux/Rostoc-x86_64.AppImage"

        # Generate checksums
        (cd "../updates/linux" && sha256sum ./*.AppImage > checksums.txt)

        echo "[INFO] Linux artifacts staged: $APPIMAGE_NAME"
        echo "appimage_name=$APPIMAGE_NAME" >> "$GITHUB_OUTPUT"

    - name: '[Linux] Upload binaries to DigitalOcean Spaces'
      if: ${{ inputs.platform == 'linux' && inputs.is_release == 'true' && steps.detect-release-token.outputs.available == 'true' }}
      working-directory: private-src
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.do_spaces_access_key }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.do_spaces_secret_key }}
        AWS_DEFAULT_REGION: sgp1
        SPACES_BUCKET: ${{ inputs.do_spaces_bucket }}
        SPACES_ENDPOINT: ${{ inputs.do_spaces_endpoint }}
        VERSION: ${{ inputs.version }}
        RELEASE_PREFIX: ${{ inputs.variant == 'staging' && 'releases/staging' || 'releases' }}
      run: |
        set -euo pipefail

        # Install AWS CLI if not present
        if ! command -v aws &> /dev/null; then
          echo "Installing AWS CLI..."
          pip install --quiet awscli
        fi

        RELEASE_PREFIX=${RELEASE_PREFIX:-releases}
        echo "[INFO] Uploading Linux binaries to Spaces: ${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/"

        # Upload Linux AppImage
        aws s3 cp \
          --endpoint-url "${SPACES_ENDPOINT}" \
          "../updates/linux/Rostoc-${VERSION}-x86_64.AppImage" \
          "s3://${SPACES_BUCKET}/${RELEASE_PREFIX}/v${VERSION}/Rostoc-${VERSION}-x86_64.AppImage" \
          --acl public-read

        echo "[INFO] ✅ Linux upload complete"

    # ======== Upload for manifest generation ========
    - name: Upload artifacts for manifest generation
      if: ${{ inputs.is_release == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.variant == 'staging' && 'rostoc-updates-staging' || 'rostoc-updates' }}-${{ inputs.platform }}-${{ inputs.arch }}
        path: updates/*
