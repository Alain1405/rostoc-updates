name: 'Build Compile (Download Python, Build, Stage)'
description: 'Download Python runtime, install JS deps, stamp version, compile application'

inputs:
  platform:
    description: 'Platform being built (macos, windows, linux)'
    required: true
  arch:
    description: 'Architecture being built (aarch64, x86_64, i686)'
    required: true
  variant:
    description: 'Build variant (production, staging)'
    required: true
  is_release:
    description: 'Whether this is a release build'
    required: false
    default: 'false'
  apple_signing_identity:
    description: 'Apple signing identity (macOS signing)'
    required: false
  apple_team_id:
    description: 'Apple Team ID (macOS signing)'
    required: false
  apple_id:
    description: 'Apple ID (notarytool)'
    required: false
  apple_app_specific_password:
    description: 'App-specific password for Apple ID (notarytool)'
    required: false
  tauri_signing_private_key:
    description: 'Tauri updater signing key'
    required: false
  tauri_signing_private_key_password:
    description: 'Password for the Tauri updater signing key'
    required: false

outputs:
  build_command:
    description: 'Build command used'
    value: ${{ steps.platform_config.outputs.build_command }}
  target:
    description: 'Rust target triple'
    value: ${{ steps.platform_config.outputs.target }}

runs:
  using: 'composite'
  steps:
    - name: Initialize platform-specific config
      id: platform_config
      shell: bash
      run: |
        set -euo pipefail

        # Add --mode development and --features devtools for staging builds
        # --mode development: Enables TanStack Router DevTools (Vite MODE=development)
        # --features devtools: Enables Tauri WebView DevTools (right-click inspect)
        MODE_FLAG=""
        FEATURES_FLAG=""
        CONFIG_FLAG=""
        if [ "${ROSTOC_APP_VARIANT:-production}" == "staging" ]; then
          MODE_FLAG="--mode development"
          FEATURES_FLAG="--features devtools"
          CONFIG_FLAG="--config src-tauri/tauri.staging.conf.json"
          # Export for build.py to pass to generate_python_config.py
          echo "TAURI_CONFIG_FLAG=src-tauri/tauri.staging.conf.json" >> "$GITHUB_ENV"
        fi

        case "${{ inputs.platform }}" in
          macos)
            {
              echo "build_command=python scripts/build.py --locked $MODE_FLAG $FEATURES_FLAG"
              echo "artifact_extension=tar.gz"
              echo "test_smoke=true"
              if [ "${{ inputs.arch }}" == "x86_64" ]; then
                echo "target=x86_64-apple-darwin"
                echo "py_url_fragment=macos-x64"
              else
                echo "target=aarch64-apple-darwin"
                echo "py_url_fragment=macos-arm64"
              fi
            } >> "$GITHUB_OUTPUT"
            ;;
          windows)
            {
              if [ "${{ inputs.arch }}" == "x86_64" ]; then
                echo "build_command=python scripts/build.py --locked --bundles msi $MODE_FLAG $FEATURES_FLAG"
                echo "target=x86_64-pc-windows-msvc"
                echo "py_url_fragment=windows-x64"
              else
                # For 32-bit Windows, pass --target to Tauri CLI so WiX creates 32-bit MSI
                echo "build_command=python scripts/build.py --locked --bundles msi --target i686-pc-windows-msvc $MODE_FLAG $FEATURES_FLAG"
                echo "target=i686-pc-windows-msvc"
                echo "py_url_fragment=windows-x86"
              fi
              echo "artifact_extension=msi"
              echo "test_smoke=true"
            } >> "$GITHUB_OUTPUT"
            ;;
          linux)
            {
              echo "build_command=python scripts/build.py --locked --bundles appimage $MODE_FLAG $FEATURES_FLAG"
              echo "artifact_extension=AppImage"
              echo "test_smoke=true"
              echo "target=x86_64-unknown-linux-gnu"
              echo "py_url_fragment=linux-x64"
            } >> "$GITHUB_OUTPUT"
            ;;
          *)
            echo "::error::Unknown platform: ${{ inputs.platform }}"
            exit 1
            ;;
        esac

    - name: '[macOS Intel] Confirm runner architecture'
      if: ${{ inputs.arch == 'x86_64' && inputs.platform == 'macos' }}
      shell: bash
      run: |
        RUNNER_ARCH=$(uname -m)
        if [ "$RUNNER_ARCH" != "x86_64" ]; then
          echo "::warning::Runner reports architecture $RUNNER_ARCH but matrix specifies x86_64"
        fi
        echo "[INFO] macOS runner architecture: $RUNNER_ARCH"
        uname -a

    - name: '[macOS Intel] Clear stale pyembed (force x86_64 download)'
      if: ${{ inputs.arch == 'x86_64' && inputs.platform == 'macos' }}
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        if [ -d src-tauri/pyembed ]; then
          echo "[INFO] Removing existing src-tauri/pyembed to avoid arm64 leftovers"
          rm -rf src-tauri/pyembed
        fi

    - name: '[Windows x64] Clear stale pyembed (force x86_64 download)'
      if: ${{ inputs.arch == 'x86_64' && inputs.platform == 'windows' }}
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        if [ -d src-tauri/pyembed ]; then
          echo "[INFO] Removing existing src-tauri/pyembed to avoid i686 leftovers"
          rm -rf src-tauri/pyembed
        fi

    - name: '[Windows x86] Verify cross-compile capability'
      if: ${{ inputs.arch == 'i686' && inputs.platform == 'windows' }}
      shell: bash
      run: |
        echo "[INFO] Windows x86 (32-bit) build via MSVC cross-compile on x64 runner"
        rustup target add i686-pc-windows-msvc
        echo "âœ… i686-pc-windows-msvc target installed"
        echo "CARGO_BUILD_TARGET=i686-pc-windows-msvc" >> "$GITHUB_ENV"
        echo "âœ… CARGO_BUILD_TARGET environment variable set for automatic cross-compilation"

    - name: '[Linux] Install system dependencies for AppImage'
      if: ${{ inputs.platform == 'linux' }}
      shell: bash
      run: |
        sudo apt-get update -qq
        # Tauri v2 + WebKit 4.1 dependencies for AppImage
        # libfuse2 is required by AppImage tools (linuxdeploy is itself an AppImage)
        # librsvg2-dev and libayatana-appindicator3-dev are required for proper GTK bundling
        # libwebp-dev is required for image processing support
        sudo apt-get install -y \
          libssl-dev \
          libffi-dev \
          libglib2.0-0 \
          libglib2.0-dev \
          libgtk-3-dev \
          libwebkit2gtk-4.1-dev \
          libjavascriptcoregtk-4.1-dev \
          librsvg2-dev \
          libayatana-appindicator3-dev \
          libwebp-dev \
          patchelf \
          pkg-config \
          libx11-6 \
          fuse3 \
          libfuse2
        echo "âœ… AppImage build dependencies installed"

    - name: Download embedded Python
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        case "${{ inputs.platform }}" in
          macos)
            if [ "${{ inputs.arch }}" = "x86_64" ]; then
              PYTHON_TARGET="x86_64-apple-darwin"
            else
              PYTHON_TARGET="aarch64-apple-darwin"
            fi
            PYTHON_TARGET="$PYTHON_TARGET" bash scripts/macos/download-py.sh
            ;;
          windows)
            if [ "${{ inputs.arch }}" = "i686" ]; then
              PYTHON_TARGET="i686-pc-windows-msvc"
            else
              PYTHON_TARGET="x86_64-pc-windows-msvc"
            fi
            PYTHON_TARGET="$PYTHON_TARGET" pwsh scripts/windows/download-py.ps1
            ;;
          linux)
            PYTHON_TARGET="x86_64-unknown-linux-gnu" bash scripts/linux/download-py.sh
            ;;
        esac

    - name: Verify embedded Python architecture
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        echo "ðŸ” Verifying embedded Python architecture matches target: ${{ inputs.arch }}"

        case "${{ inputs.platform }}" in
          windows)
            PYTHON_EXE="src-tauri/pyembed/python/python.exe"
            ;;
          *)
            PYTHON_EXE="src-tauri/pyembed/python/bin/python3"
            ;;
        esac

        if [ ! -f "$PYTHON_EXE" ]; then
          echo "âŒ ERROR: Embedded Python not found at $PYTHON_EXE"
          echo "Contents of src-tauri/pyembed/:"
          ls -la src-tauri/pyembed/ || echo "Directory does not exist"
          exit 1
        fi

        # Get Python architecture
        PYTHON_INFO=$($PYTHON_EXE -c "import platform, sys; print(f'{platform.machine()},{sys.maxsize > 2**32}')" 2>&1)
        MACHINE=$(echo "$PYTHON_INFO" | cut -d',' -f1)
        IS_64BIT=$(echo "$PYTHON_INFO" | cut -d',' -f2)

        echo "ðŸ“Š Embedded Python info:"
        echo "  - Machine: $MACHINE"
        echo "  - 64-bit: $IS_64BIT"
        echo "  - Target arch: ${{ inputs.arch }}"

        # Validate architecture matches
        if [ "${{ inputs.arch }}" = "x86_64" ] || [ "${{ inputs.arch }}" = "aarch64" ]; then
          if [ "$IS_64BIT" != "True" ]; then
            echo "âŒ ERROR: Expected 64-bit Python for ${{ inputs.arch }} target, but got 32-bit!"
            exit 1
          fi
        elif [ "${{ inputs.arch }}" = "i686" ]; then
          if [ "$IS_64BIT" != "False" ]; then
            echo "âŒ ERROR: Expected 32-bit Python for i686 target, but got 64-bit!"
            exit 1
          fi
        fi

        echo "âœ… Embedded Python architecture matches target"

    - name: Install JS dependencies
      working-directory: private-src
      shell: bash
      run: pnpm install --frozen-lockfile

    - name: Stamp build version (dev builds only)
      if: env.RELEASE_VERSION == ''
      working-directory: private-src
      shell: bash
      env:
        GITHUB_SHA: ${{ github.sha }}
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        set -euo pipefail
        # Dev builds: generate unique version and update Cargo.lock
        scripts/ci/stamp_dev_version.sh

    - name: Set variant-specific Tauri config flag
      shell: bash
      run: |
        case "${ROSTOC_APP_VARIANT:-production}" in
          staging)
            echo "TAURI_CONFIG_FLAG=src-tauri/tauri.staging.conf.json" >> "$GITHUB_ENV"
            ;;
          dev)
            echo "TAURI_CONFIG_FLAG=src-tauri/tauri.dev.conf.json" >> "$GITHUB_ENV"
            ;;
          production)
            echo "TAURI_CONFIG_FLAG=" >> "$GITHUB_ENV"
            ;;
          *)
            echo "::warning::Unknown variant '$ROSTOC_APP_VARIANT', defaulting to production"
            echo "TAURI_CONFIG_FLAG=" >> "$GITHUB_ENV"
            ;;
        esac
        echo "[INFO] TAURI_CONFIG_FLAG=${TAURI_CONFIG_FLAG:-<empty>}"

    - name: Capture diagnostic environment info
      if: always()
      shell: bash
      working-directory: private-src
      run: |
        {
          echo "# Build Environment Diagnostics"
          echo ""
          echo "**Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "**Runner**: ${{ runner.os }} ${{ runner.arch }}"
          echo "**Platform**: ${{ inputs.platform }}"
          echo "**Architecture**: ${{ inputs.arch }}"
          echo "**Variant**: ${ROSTOC_APP_VARIANT}"
          echo ""
          
          echo "## Disk Space"
          df -h . || true
          echo ""
          
          echo "## Installed Tools"
          echo "- Node: $(node --version 2>/dev/null || echo 'not installed')"
          echo "- pnpm: $(pnpm --version 2>/dev/null || echo 'not installed')"
          echo "- Rust: $(rustc --version 2>/dev/null || echo 'not installed')"
          echo "- Python: $(python3 --version 2>/dev/null || echo 'not installed')"
          echo "- uv: $(uv --version 2>/dev/null || echo 'not installed')"
          
          if [[ "${{ inputs.platform }}" == "macos" ]]; then
            echo "- codesign: $(codesign --version 2>&1 | head -1 || echo 'not available')"
            echo "- xcrun: $(xcrun --version 2>&1 || echo 'not available')"
          fi
          echo ""
          
          echo "## Environment Variables"
          echo '```'
          env | grep -E '^(ROSTOC|TAURI|SENTRY|GITHUB|RUNNER|PYO3)' | sort || true
          echo '```'
          echo ""
          
          echo "## Available Tauri Configs"
          find src-tauri -maxdepth 1 -name "tauri*.json" -exec basename {} \; | sort
          echo ""
          
          echo "## Python Runtime Status"
          if [[ -d "build/runtime_staging" ]]; then
            echo "Runtime staged: YES"
            find build/runtime_staging -type f -name "python*" -o -name "*.dll" -o -name "*.dylib" 2>/dev/null | head -20
          else
            echo "Runtime staged: NO"
          fi
        } > diagnostics-${{ inputs.platform }}-${{ inputs.arch }}.md

    - name: Upload diagnostic info
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: diagnostics-${{ inputs.variant }}-${{ inputs.platform }}-${{ inputs.arch }}-${{ github.run_number }}
        path: private-src/diagnostics-*.md
        retention-days: 14
        if-no-files-found: warn

    - name: Generate build fingerprint
      shell: bash
      working-directory: private-src
      run: |
        {
          echo "# Build Fingerprint"
          echo "timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "platform: ${{ inputs.platform }}"
          echo "arch: ${{ inputs.arch }}"
          echo "variant: ${ROSTOC_APP_VARIANT}"
          echo "runner_os: ${{ runner.os }}"
          echo "github_sha: ${{ github.sha }}"
          echo "github_run_number: ${{ github.run_number }}"
          echo ""
          echo "# Dependencies"
          echo "package_json_hash: $(shasum package.json 2>/dev/null | awk '{print $1}' || echo 'N/A')"
          echo "cargo_lock_hash: $(shasum src-tauri/Cargo.lock 2>/dev/null | awk '{print $1}' || echo 'N/A')"
          echo "pnpm_lock_hash: $(shasum pnpm-lock.yaml 2>/dev/null | awk '{print $1}' || echo 'N/A')"
          echo ""
          echo "# Tool Versions"
          echo "node: $(node --version 2>/dev/null || echo 'unknown')"
          echo "rust: $(rustc --version 2>/dev/null || echo 'unknown')"
          echo "python: $(python3 --version 2>/dev/null || echo 'unknown')"
          echo ""
          echo "# Config Selection"
          echo "tauri_config: ${TAURI_CONFIG_FLAG:-<base>}"
          if [[ -n "${TAURI_CONFIG_FLAG}" && -f "${TAURI_CONFIG_FLAG}" ]]; then
            echo "config_hash: $(shasum "${TAURI_CONFIG_FLAG}" 2>/dev/null | awk '{print $1}' || echo 'N/A')"
          fi
        } > build-fingerprint.txt

    - name: Upload build fingerprint
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: fingerprint-${{ inputs.variant }}-${{ inputs.platform }}-${{ inputs.arch }}-${{ github.run_number }}
        path: private-src/build-fingerprint.txt
        retention-days: 30
        if-no-files-found: warn

    - name: Generate Python config (before runtime staging)
      working-directory: private-src
      shell: bash
      run: ../scripts/ci/generate_and_verify_config.sh

    - name: '[macOS] Stage Python runtime (before Tauri build/sign)'
      if: ${{ inputs.platform == 'macos' }}
      working-directory: private-src
      shell: bash
      run: ../scripts/ci/stage_and_verify_runtime.sh

    - name: '[macOS] Sign Python binaries and libraries (before Tauri build)'
      if: ${{ inputs.platform == 'macos' }}
      working-directory: private-src
      shell: bash
      env:
        APPLE_SIGNING_IDENTITY: ${{ inputs.apple_signing_identity }}
      run: ../scripts/ci/sign_python_runtime.sh

    - name: '[macOS] Verify generated_config.py after signing'
      if: ${{ inputs.platform == 'macos' }}
      working-directory: private-src
      shell: bash
      run: ../scripts/ci/verify_config_after_signing.sh

    - name: '[Windows] Stage Python runtime (before Tauri build)'
      if: ${{ inputs.platform == 'windows' }}
      working-directory: private-src
      shell: bash
      run: ../scripts/ci/stage_and_verify_runtime.sh

    - name: '[Windows] Set PYO3_PYTHON for correct embedded Python linking'
      if: ${{ inputs.platform == 'windows' }}
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        echo "ðŸ”§ Configuring PyO3 to use staged embedded Python..."

        PYTHON_EXE="$(pwd)/build/runtime_staging/pyembed/python/python.exe"
        if [ ! -f "$PYTHON_EXE" ]; then
          echo "âŒ ERROR: Staged Python not found at $PYTHON_EXE"
          echo "   This should have been created by the staging step."
          ls -la build/runtime_staging/ 2>/dev/null || echo "   Staging directory doesn't exist!"
          exit 1
        fi

        # Verify architecture matches target BEFORE setting PYO3_PYTHON
        echo "ðŸ” Verifying Python architecture matches target: ${{ inputs.arch }}"
        ARCH_INFO=$("$PYTHON_EXE" -c "import platform, sys; print(f'{platform.machine()},{sys.maxsize > 2**32}')" 2>&1)
        MACHINE=$(echo "$ARCH_INFO" | cut -d',' -f1)
        IS_64BIT=$(echo "$ARCH_INFO" | cut -d',' -f2)

        # Validate architecture
        EXPECTED_64BIT=""
        if [ "${{ inputs.arch }}" = "x86_64" ]; then
          EXPECTED_64BIT="True"
        elif [ "${{ inputs.arch }}" = "i686" ]; then
          EXPECTED_64BIT="False"
        fi

        if [ -n "$EXPECTED_64BIT" ] && [ "$IS_64BIT" != "$EXPECTED_64BIT" ]; then
          echo "âŒ ERROR: Python architecture mismatch!"
          echo "   Target: ${{ inputs.arch }} ($([ "$EXPECTED_64BIT" = "True" ] && echo "64-bit" || echo "32-bit"))"
          echo "   Python: $MACHINE ($IS_64BIT = $([ "$IS_64BIT" = "True" ] && echo "64-bit" || echo "32-bit"))"
          echo "   This will cause PyO3 compilation to fail."
          exit 1
        fi

        # Convert to Windows path for PyO3
        PYTHON_EXE_WIN=$(cygpath -w "$PYTHON_EXE" 2>/dev/null || echo "$PYTHON_EXE")
        echo "PYO3_PYTHON=$PYTHON_EXE_WIN" >> "$GITHUB_ENV"

        echo "âœ… PYO3_PYTHON configured: $PYTHON_EXE_WIN"
        echo "   Architecture: $MACHINE ($([ "$IS_64BIT" = "True" ] && echo "64-bit" || echo "32-bit")) - matches target ${{ inputs.arch }}"

    - name: Validate version matches tag (release builds only)
      if: ${{ inputs.is_release == 'true' }}
      working-directory: private-src
      shell: bash
      env:
        GITHUB_REF: ${{ github.ref }}
      run: ../scripts/ci/validate_release_version.sh

    - name: Build application
      working-directory: private-src
      shell: bash
      env:
        # Variant configuration (must be set for Rust compile-time option_env! macro)
        ROSTOC_APP_VARIANT: ${{ env.ROSTOC_APP_VARIANT }}
        TAURI_SIGNING_PRIVATE_KEY: ${{ inputs.tauri_signing_private_key }}
        TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ inputs.tauri_signing_private_key_password }}
        APPLE_SIGNING_IDENTITY: ${{ inputs.apple_signing_identity }}
        APPLE_TEAM_ID: ${{ inputs.apple_team_id }}
        APPLE_ID: ${{ inputs.apple_id }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ inputs.apple_app_specific_password }}
        ENABLE_RUNTIME_CACHE: '1'
        UV_DISABLE_WORKSPACE: '1'
        UV_PROJECT_ENVIRONMENT: 'shared'
        RUST_TARGET: ${{ steps.platform_config.outputs.target }}
        CROSS_COMPILE_ARGS: ${{ steps.platform_config.outputs.cross_compile_args || '' }}
        # Skip rosi (and its pandas dependency) on optional 32-bit Windows builds
        SKIP_ROSI: ${{ inputs.platform == 'windows' && inputs.arch == 'i686' && '1' || '' }}
        # Linux AppImage workarounds for FUSE and linuxdeploy issues
        APPIMAGE_EXTRACT_AND_RUN: ${{ inputs.platform == 'linux' && '1' || '' }}
        NO_STRIP: ${{ inputs.platform == 'linux' && '1' || '' }}
        OUTPUT: ${{ inputs.platform == 'linux' && '2' || '' }}
        VERBOSE: ${{ inputs.platform == 'linux' && '1' || '' }}
        # Enable debug symbols for build dependencies (better error traces)
        CARGO_PROFILE_RELEASE_BUILD_OVERRIDE_DEBUG: 'true'
        # PYO3_PYTHON is set by previous step for Windows, inherited for other platforms
      run: ../scripts/ci/execute_build.sh "${{ inputs.platform }}" "${{ inputs.arch }}" "${{ steps.platform_config.outputs.build_command }}"
