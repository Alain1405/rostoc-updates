name: 'Build Compile (Download Python, Build, Stage)'
description: 'Download Python runtime, install JS deps, stamp version, compile application'

inputs:
  platform:
    description: 'Platform being built (macos, windows, linux)'
    required: true
  arch:
    description: 'Architecture being built (aarch64, x86_64, i686)'
    required: true
  is_release:
    description: 'Whether this is a release build'
    required: false
    default: 'false'
  apple_signing_identity:
    description: 'Apple signing identity (macOS signing)'
    required: false
  apple_team_id:
    description: 'Apple Team ID (macOS signing)'
    required: false
  apple_id:
    description: 'Apple ID (notarytool)'
    required: false
  apple_app_specific_password:
    description: 'App-specific password for Apple ID (notarytool)'
    required: false
  tauri_signing_private_key:
    description: 'Tauri updater signing key'
    required: false
  tauri_signing_private_key_password:
    description: 'Password for the Tauri updater signing key'
    required: false

outputs:
  build_command:
    description: 'Build command used'
    value: ${{ steps.platform_config.outputs.build_command }}
  target:
    description: 'Rust target triple'
    value: ${{ steps.platform_config.outputs.target }}

runs:
  using: 'composite'
  steps:
    - name: Initialize platform-specific config
      id: platform_config
      shell: bash
      run: |
        set -euo pipefail

        # Add --mode development and --features devtools for staging builds
        # --mode development: Enables TanStack Router DevTools (Vite MODE=development)
        # --features devtools: Enables Tauri WebView DevTools (right-click inspect)
        MODE_FLAG=""
        FEATURES_FLAG=""
        CONFIG_FLAG=""
        if [ "${ROSTOC_APP_VARIANT:-production}" == "staging" ]; then
          MODE_FLAG="--mode development"
          FEATURES_FLAG="--features devtools"
          CONFIG_FLAG="--config src-tauri/tauri.staging.conf.json"
          # Export for build.py to pass to generate_python_config.py
          echo "TAURI_CONFIG_FLAG=src-tauri/tauri.staging.conf.json" >> "$GITHUB_ENV"
        fi

        case "${{ inputs.platform }}" in
          macos)
            {
              echo "build_command=python scripts/build.py --locked $MODE_FLAG $FEATURES_FLAG"
              echo "artifact_extension=tar.gz"
              echo "test_smoke=true"
              if [ "${{ inputs.arch }}" == "x86_64" ]; then
                echo "target=x86_64-apple-darwin"
                echo "py_url_fragment=macos-x64"
              else
                echo "target=aarch64-apple-darwin"
                echo "py_url_fragment=macos-arm64"
              fi
            } >> "$GITHUB_OUTPUT"
            ;;
          windows)
            {
              if [ "${{ inputs.arch }}" == "x86_64" ]; then
                echo "build_command=python scripts/build.py --locked --bundles msi $MODE_FLAG $FEATURES_FLAG"
                echo "target=x86_64-pc-windows-msvc"
                echo "py_url_fragment=windows-x64"
              else
                # For 32-bit Windows, pass --target to Tauri CLI so WiX creates 32-bit MSI
                echo "build_command=python scripts/build.py --locked --bundles msi --target i686-pc-windows-msvc $MODE_FLAG $FEATURES_FLAG"
                echo "target=i686-pc-windows-msvc"
                echo "py_url_fragment=windows-x86"
              fi
              echo "artifact_extension=msi"
              echo "test_smoke=true"
            } >> "$GITHUB_OUTPUT"
            ;;
          linux)
            {
              echo "build_command=python scripts/build.py --locked --bundles appimage $MODE_FLAG $FEATURES_FLAG"
              echo "artifact_extension=AppImage"
              echo "test_smoke=true"
              echo "target=x86_64-unknown-linux-gnu"
              echo "py_url_fragment=linux-x64"
            } >> "$GITHUB_OUTPUT"
            ;;
          *)
            echo "::error::Unknown platform: ${{ inputs.platform }}"
            exit 1
            ;;
        esac

    - name: '[macOS Intel] Confirm runner architecture'
      if: ${{ inputs.arch == 'x86_64' && inputs.platform == 'macos' }}
      shell: bash
      run: |
        RUNNER_ARCH=$(uname -m)
        if [ "$RUNNER_ARCH" != "x86_64" ]; then
          echo "::warning::Runner reports architecture $RUNNER_ARCH but matrix specifies x86_64"
        fi
        echo "[INFO] macOS runner architecture: $RUNNER_ARCH"
        uname -a

    - name: '[macOS Intel] Clear stale pyembed (force x86_64 download)'
      if: ${{ inputs.arch == 'x86_64' && inputs.platform == 'macos' }}
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        if [ -d src-tauri/pyembed ]; then
          echo "[INFO] Removing existing src-tauri/pyembed to avoid arm64 leftovers"
          rm -rf src-tauri/pyembed
        fi

    - name: '[Windows x86] Verify cross-compile capability'
      if: ${{ inputs.arch == 'i686' && inputs.platform == 'windows' }}
      shell: bash
      run: |
        echo "[INFO] Windows x86 (32-bit) build via MSVC cross-compile on x64 runner"
        rustup target add i686-pc-windows-msvc
        echo "âœ… i686-pc-windows-msvc target installed"
        echo "CARGO_BUILD_TARGET=i686-pc-windows-msvc" >> "$GITHUB_ENV"
        echo "âœ… CARGO_BUILD_TARGET environment variable set for automatic cross-compilation"

    - name: '[Linux] Install system dependencies for AppImage'
      if: ${{ inputs.platform == 'linux' }}
      shell: bash
      run: |
        sudo apt-get update -qq
        # Tauri v2 + WebKit 4.1 dependencies for AppImage
        # libfuse2 is required by AppImage tools (linuxdeploy is itself an AppImage)
        # librsvg2-dev and libayatana-appindicator3-dev are required for proper GTK bundling
        # libwebp-dev is required for image processing support
        sudo apt-get install -y \
          libssl-dev \
          libffi-dev \
          libglib2.0-0 \
          libglib2.0-dev \
          libgtk-3-dev \
          libwebkit2gtk-4.1-dev \
          libjavascriptcoregtk-4.1-dev \
          librsvg2-dev \
          libayatana-appindicator3-dev \
          libwebp-dev \
          patchelf \
          pkg-config \
          libx11-6 \
          fuse3 \
          libfuse2
        echo "âœ… AppImage build dependencies installed"

    - name: Download embedded Python
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        case "${{ inputs.platform }}" in
          macos)
            if [ "${{ inputs.arch }}" = "x86_64" ]; then
              PYTHON_TARGET="x86_64-apple-darwin"
            else
              PYTHON_TARGET="aarch64-apple-darwin"
            fi
            PYTHON_TARGET="$PYTHON_TARGET" bash scripts/macos/download-py.sh
            ;;
          windows)
            if [ "${{ inputs.arch }}" = "i686" ]; then
              PYTHON_TARGET="i686-pc-windows-msvc"
            else
              PYTHON_TARGET="x86_64-pc-windows-msvc"
            fi
            PYTHON_TARGET="$PYTHON_TARGET" pwsh scripts/windows/download-py.ps1
            ;;
          linux)
            PYTHON_TARGET="x86_64-unknown-linux-gnu" bash scripts/linux/download-py.sh
            ;;
        esac

    - name: Install JS dependencies
      working-directory: private-src
      shell: bash
      run: pnpm install --frozen-lockfile

    - name: Stamp build version
      working-directory: private-src
      shell: bash
      env:
        GITHUB_SHA: ${{ github.sha }}
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        set -euo pipefail
        if [[ -n "${RELEASE_VERSION:-}" ]]; then
          scripts/ci/stamp_dev_version.sh --version "$RELEASE_VERSION"
        else
          scripts/ci/stamp_dev_version.sh
        fi

    - name: Set variant-specific Tauri config flag
      shell: bash
      run: |
        case "${ROSTOC_APP_VARIANT:-production}" in
          staging)
            echo "TAURI_CONFIG_FLAG=src-tauri/tauri.staging.conf.json" >> "$GITHUB_ENV"
            ;;
          dev)
            echo "TAURI_CONFIG_FLAG=src-tauri/tauri.dev.conf.json" >> "$GITHUB_ENV"
            ;;
          production)
            echo "TAURI_CONFIG_FLAG=" >> "$GITHUB_ENV"
            ;;
          *)
            echo "::warning::Unknown variant '$ROSTOC_APP_VARIANT', defaulting to production"
            echo "TAURI_CONFIG_FLAG=" >> "$GITHUB_ENV"
            ;;
        esac
        echo "[INFO] TAURI_CONFIG_FLAG=${TAURI_CONFIG_FLAG:-<empty>}"

    - name: Generate Python config (before runtime staging)
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        echo "::group::ğŸ”§ Generating Python config from Tauri config"
        echo "[DEBUG] PWD: $(pwd)"
        echo "[DEBUG] ROSTOC_APP_VARIANT: ${ROSTOC_APP_VARIANT:-<not set>}"
        echo "[DEBUG] TAURI_CONFIG_FLAG: ${TAURI_CONFIG_FLAG:-<not set>}"
        
        if [ -n "${TAURI_CONFIG_FLAG:-}" ]; then
          echo "[INFO] Generating Python config with overlay: $TAURI_CONFIG_FLAG"
          python3 scripts/generate_python_config.py --config "$TAURI_CONFIG_FLAG"
        else
          echo "[INFO] Generating Python config (production)"
          python3 scripts/generate_python_config.py
        fi
        
        # Verify file was created
        CONFIG_PATH="src-tauri/src-python/rostoc/generated_config.py"
        if [ -f "$CONFIG_PATH" ]; then
          echo "[DEBUG] âœ… generated_config.py created at: $CONFIG_PATH"
          echo "[DEBUG] File size: $(wc -c < "$CONFIG_PATH") bytes"
          echo "[DEBUG] Contents preview:"
          head -20 "$CONFIG_PATH" | sed 's/^/  /'
        else
          echo "::error::âŒ generated_config.py was NOT created at expected path: $CONFIG_PATH"
          exit 1
        fi
        echo "::endgroup::"

    - name: '[macOS] Stage Python runtime (before Tauri build/sign)'
      if: ${{ inputs.platform == 'macos' }}
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        echo "::group::ğŸ Staging Python runtime"
        echo "[INFO] Pre-staging Python runtime to ensure stable file attributes before signing"
        
        # Verify generated_config.py exists before staging
        CONFIG_PATH="src-tauri/src-python/rostoc/generated_config.py"
        if [ -f "$CONFIG_PATH" ]; then
          echo "[DEBUG] âœ… generated_config.py exists before staging"
        else
          echo "::error::âŒ generated_config.py missing before staging! This will cause fallback to production values."
          exit 1
        fi
        
        python3 scripts/bundle_runtime.py --target=release --stage-only
        
        # Verify file was included in staged runtime
        STAGED_CONFIG="build/runtime_staging/pyembed/python/lib/python3.13/site-packages/rostoc/generated_config.py"
        if [ -f "$STAGED_CONFIG" ]; then
          echo "[DEBUG] âœ… generated_config.py included in staged runtime"
          echo "[DEBUG] Staged file size: $(wc -c < "$STAGED_CONFIG") bytes"
        else
          echo "::error::âŒ generated_config.py NOT found in staged runtime at: $STAGED_CONFIG"
          echo "[DEBUG] Listing rostoc package contents:"
          ls -la "build/runtime_staging/pyembed/python/lib/python3.13/site-packages/rostoc/" || true
          exit 1
        fi
        
        echo "[INFO] Runtime staging complete - files are now stable for Tauri's signing"
        echo "::endgroup::"

    - name: '[macOS] Sign Python binaries in staging (before sync to src-tauri)'
      if: ${{ inputs.platform == 'macos' }}
      working-directory: private-src
      shell: bash
      env:
        APPLE_SIGNING_IDENTITY: ${{ inputs.apple_signing_identity }}
      run: |
        set -euo pipefail
        echo "[INFO] Signing Python binaries and libraries in build/runtime_staging/pyembed/python"
        echo "[INFO] These will be synced to src-tauri/ by build.py, preserving signatures"

        # Sign all executables in bin/
        if ['[macOS] Verify generated_config.py after signing'
      if: ${{ inputs.platform == 'macos' }}
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        echo "::group::ğŸ” Verifying generated_config.py persistence"
        STAGED_CONFIG="build/runtime_staging/pyembed/python/lib/python3.13/site-packages/rostoc/generated_config.py"
        if [ -f "$STAGED_CONFIG" ]; then
          echo "[DEBUG] âœ… generated_config.py still present after signing"
        else
          echo "::error::âŒ generated_config.py disappeared after signing!"
          exit 1
        fi
        echo "::endgroup::"

    - name:  -d "build/runtime_staging/pyembed/python/bin" ]; then
          find build/runtime_staging/pyembed/python/bin -type f \( -perm +111 -o -name "python*" \) | while read -r binary; do
            if file "$binary" | grep -q "Mach-O"; then
              echo "  Signing: $(basename "$binary")"
              codesign --force --sign "$APPLE_SIGNING_IDENTITY" \
                --timestamp \
                --options runtime \
                "$binary" || echo "    Warning: failed to sign $binary"
            fi
          done
        fi

        # Sign all dylibs and .so files in lib/
        if [ -d "build/runtime_staging/pyembed/python/lib" ]; then
          find build/runtime_staging/pyembed/python/lib -type f \( -name "*.dylib" -o -name "*.so" \) | while read -r lib; do
            echo "  Signing: $(basename "$lib")"
            codesign --force --sign "$APPLE_SIGNING_IDENTITY" \
              --timestamp \
              --options runtime \
              "$lib" || echo "    Warning: failed to sign $lib"
          done
        fi

        echo "[INFO] Python runtime signing complete in staging area"

    - name: Validate version matches tag (release builds only)
      if: ${{ inputs.is_release == 'true' }}
      working-directory: private-src
      shell: bash
      run: |
        set -euo pipefail
        VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
        REF="${{ github.ref }}"

        if [[ "$REF" =~ ^refs/tags/v([0-9]+\.[0-9]+\.[0-9]+.*)$ ]]; then
          TAG_VERSION="${BASH_REMATCH[1]}"
          echo "[INFO] Tag version: $TAG_VERSION"
          echo "[INFO] Code version: $VERSION"

          ifaging)
            echo "TAURI_CONFIG_FLAG=src-tauri/tauri.staging.conf.json" >> "$GITHUB_ENV"
            ;;
          dev)
            echo "TAURI_CONFIG_FLAG=src-tauri/tauri.dev.conf.json" >> "$GITHUB_ENV"
            ;;
          production)
            echo "TAURI_CONFIG_FLAG=" >> "$GITHUB_ENV"
            ;;
          *)
            echo "::warning::Unknown variant '$ROSTOC_APP_VARIANT', defaulting to production"
            echo "TAURI_CONFIG_FLAG=" >> "$GITHUB_ENV"
            ;;
        esac
        echo "[INFO] TAURI_CONFIG_FLAG=${TAURI_CONFIG_FLAG:-<empty>}"

    - name: Build application
      working-directory: private-src
      shell: bash
      env:
        # Variant configuration (must be set for Rust compile-time option_env! macro)
        ROSTOC_APP_VARIANT: ${{ env.ROSTOC_APP_VARIANT }}
        TAURI_SIGNING_PRIVATE_KEY: ${{ inputs.tauri_signing_private_key }}
        TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ inputs.tauri_signing_private_key_password }}
        APPLE_SIGNING_IDENTITY: ${{ inputs.apple_signing_identity }}
        APPLE_TEAM_ID: ${{ inputs.apple_team_id }}
        APPLE_ID: ${{ inputs.apple_id }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ inputs.apple_app_specific_password }}
        ENABLE_RUNTIME_CACHE: '1'
        UV_DISABLE_WORKSPACE: '1'
        UV_PROJECT_ENVIRONMENT: 'shared'
        RUST_TARGET: ${{ steps.platform_config.outputs.target }}
        CROSS_COMPILE_ARGS: ${{ steps.platform_config.outputs.cross_compile_args || '' }}
        # Skip rosi (and its pandas dependency) on optional 32-bit Windows builds
        SKIP_ROSI: ${{ inputs.platform == 'windows' && inputs.arch == 'i686' && '1' || '' }}
        # Linux AppImage workarounds for FUSE and linuxdeploy issues
        APPIMAGE_EXTRACT_AND_RUN: ${{ inputs.platform == 'linux' && '1' || '' }}
        NO_STRIP: ${{ inputs.platform == 'linux' && '1' || '' }}
        OUTPUT: ${{ inputs.platform == 'linux' && '2' || '' }}
        VERBOSE: ${{ inputs.platform == 'linux' && '1' || '' }}
      run: |
        set -euo pipefail
        BUILD_CMD="${{ steps.platform_config.outputs.build_command }}"
        LOG_FILE="build-${{ inputs.platform }}-${{ inputs.arch }}.log"

        # Debug variant configuration (all platforms)
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "[DEBUG] Variant Configuration"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ROSTOC_APP_VARIANT=${ROSTOC_APP_VARIANT:-<not set>}"
        echo "TAURI_CONFIG_FLAG=${TAURI_CONFIG_FLAG:-<not set>}"
        echo "MODE_FLAG extracted: ${{ steps.platform_config.outputs.build_command }}" | grep -o '\-\-mode [^ ]*' || echo "  (no --mode flag)"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""

        # Debug logging for Linux builds
        if [[ "${{ inputs.platform }}" == "linux" ]]; then
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "[DEBUG] Linux AppImage Build Environment"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "APPIMAGE_EXTRACT_AND_RUN=${APPIMAGE_EXTRACT_AND_RUN:-<not set>}"
          echo "NO_STRIP=${NO_STRIP:-<not set>}"
          echo "OUTPUT=${OUTPUT:-<not set>}"
          echo "VERBOSE=${VERBOSE:-<not set>}"
          echo ""
          echo "FUSE installations:"
          dpkg -l | grep -i fuse || echo "  No FUSE packages found"
          echo ""
          echo "FUSE version: $(fusermount3 --version 2>&1 || echo 'fusermount3 not available')"
          echo "fusermount version: $(fusermount --version 2>&1 || echo 'fusermount not available')"
          echo ""
          echo "Available disk space: $(df -h . | tail -1 | awk '{print $4}')"
          echo "Kernel: $(uname -r)"
          echo "User: $(whoami)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        fi

        echo "[INFO] Starting build â€” output will be saved to $LOG_FILE"
        # shellcheck disable=SC2086
        $BUILD_CMD 2>&1 | tee "$LOG_FILE"
        BUILD_EXIT_CODE=$?

        # Post-build debug logging for Linux
        if [[ "${{ inputs.platform }}" == "linux" ]]; then
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "[DEBUG] Linux AppImage Build Results (exit code: $BUILD_EXIT_CODE)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Checking for AppImage artifacts in target directories..."
          find target -name "*.AppImage" 2>/dev/null || echo "  No AppImage found in target/"
          find src-tauri/target -name "*.AppImage" 2>/dev/null || echo "  No AppImage found in src-tauri/target/"
          
          echo ""
          echo "Last 100 lines of build log (to capture linuxdeploy errors):"
          tail -100 "$LOG_FILE" || echo "  (Could not read log file)"
          
          echo ""
          echo "Searching for error patterns in build log:"
          grep -i "error\|failed\|linuxdeploy" "$LOG_FILE" | tail -30 || echo "  (No error patterns found)"
          
          echo ""
          echo "AppImage build directory contents:"
          find src-tauri/target -type d -name "appimage" -exec sh -c 'echo "Contents of {}"; ls -lah "{}" 2>/dev/null || echo "  (directory not accessible)"' \; || echo "  (No appimage directory found)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        fi

        exit $BUILD_EXIT_CODE
